<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven安装和配置]]></title>
    <url>%2F2017%2F09%2F08%2Ff2c956c6-364b-4585-9d66-c6fcdc46d36d%2F</url>
    <content type="text"><![CDATA[下载MavenMaven &#x2013; Download Apache Maven配置环境变量Windows下配置环境变量即可，Ubuntu下在~/.bashrc里加入如下两行语句即可。12export M2_HOME=/home/alan/Documents/Applications/apache-maven-3.5.0export PATH=$M2_HOME/bin:$PATH在命令行运行mvn -v，若显示Maven版本信息则说明环境变量配置成功。配置settings.xml打开用户目录下的~/.m2/settings.xml（没有的话从安装目录的conf文件夹下复制一个过来）。配置本地仓库地址1&lt;localRepository&gt;/home/alan/Documents/Frameworks/Maven-repository&lt;/localRepository&gt;配置Maven国内镜像12345678910111213141516171819202122232425262728293031323334353637&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库在中国的镜像 --&gt;&lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode - Regular Expression Matching And Wildcard Matching]]></title>
    <url>%2F2017%2F08%2F05%2F63b658f9-a198-43aa-98e6-bd370c06892c%2F</url>
    <content type="text"><![CDATA[最近刷LeetCode遇到关于正则匹配的编程题，在这里记录下解题思路。Regular Expression MatchingLinkRegular Expression Matching - LeetCodeDescriptionImplement regular expression matching with support for ‘.’ and ‘*’.12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) ? falseisMatch(&quot;aa&quot;,&quot;aa&quot;) ? trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) ? falseisMatch(&quot;aa&quot;, &quot;a*&quot;) ? trueisMatch(&quot;aa&quot;, &quot;.*&quot;) ? trueisMatch(&quot;ab&quot;, &quot;.*&quot;) ? trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) ? trueRecursive SolutionDiscusss当模式中的第二个字符不是“*”时：如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。而当模式中的第二个字符是“*”时：如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有2种匹配方式：1) 模式后移2字符，相当于x*被忽略;2) 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位;Code12345678910111213public class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s.equals("") &amp;&amp; p.equals("")) return true; if (!s.equals("") &amp;&amp; p.equals("")) return false; if (p.length() &gt; 1 &amp;&amp; p.charAt(1) == '*') &#123; return isMatch(s, p.substring(2)) || (s.length() != 0 &amp;&amp; (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0)) &amp;&amp; isMatch(s.substring(1), p)); &#125; if (s.length() != 0 &amp;&amp; p.length() != 0 &amp;&amp; (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))) return isMatch(s.substring(1), p.substring(1)); return false; &#125;&#125;Dynamic Planning SolutionDiscusss123456781. If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2. If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3. If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] // in this case, a* counts as multiple a or dp[i][j] = dp[i][j-2] // in this case, a* counts as emptyCode123456789101112131415161718192021public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) if (p.charAt(i) == '*' &amp;&amp; dp[0][i-1]) dp[0][i+1] = true; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == '.') dp[i+1][j+1] = dp[i][j]; if (p.charAt(j) == s.charAt(i)) dp[i+1][j+1] = dp[i][j]; if (p.charAt(j) == '*') &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != '.') dp[i+1][j+1] = dp[i+1][j-1]; else dp[i+1][j+1] = (dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125;&#125;Wildcard MatchingLinkWildcard Matching - LeetCodeDescriptionImplement wildcard pattern matching with support for ‘?’ and ‘*’.12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) ? falseisMatch(&quot;aa&quot;,&quot;aa&quot;) ? trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) ? falseisMatch(&quot;aa&quot;, &quot;*&quot;) ? trueisMatch(&quot;aa&quot;, &quot;a*&quot;) ? trueisMatch(&quot;ab&quot;, &quot;?*&quot;) ? trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) ? falseRecursive SolutionDiscuss当模式中的第一个字符不是“*”时：如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。而当模式中的第一个字符是“*”时：模式后移1字符，相当于*被忽略;字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位;Code1234567891011@Deprecated//(TimeLimitExceededException)public class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s.length() == 0 &amp;&amp; p.length() == 0) return true; if (s.length() != 0 &amp;&amp; p.length() == 0) return false; if (s.length() &gt; 0 &amp;&amp; (p.charAt(0) == '?' || s.charAt(0) == p.charAt(0))) return isMatch(s.substring(1), p.substring(1)); if (p.charAt(0) == '*') return isMatch(s, p.substring(1)) || (s.length() &gt; 0 &amp;&amp; isMatch(s.substring(1), p)); return false; &#125;&#125;Dynamic Planning SolutionDiscuss1234561. If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2. If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3. If p.charAt(j) == &apos;*&apos;: here are two sub conditions: dp[i][j] = dp[i-1][j] // in this case, * counts as multiple or dp[i][j] = dp[i][j-1] // in this case, * counts as emptyCode12345678910111213public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[0][0] = true; for (int j = 0; j &lt; p.length(); j++) if (p.charAt(j) == '*' &amp;&amp; dp[0][j]) dp[0][j+1] = true; for (int i = 0; i &lt; s.length(); i++) for (int j = 0; j &lt; p.length(); j++) if (p.charAt(j) == '?' || s.charAt(i) == p.charAt(j)) dp[i+1][j+1] = dp[i][j]; else if (p.charAt(j) == '*') dp[i+1][j+1] = dp[i][j+1] || dp[i+1][j]; return dp[s.length()][p.length()]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用zxing生成和识别二维码]]></title>
    <url>%2F2017%2F08%2F03%2F15b16d90-13bb-4baa-b328-c77b2019226a%2F</url>
    <content type="text"><![CDATA[准备工作zxing包似乎没有提供相关的Jar包下载，那么我们首先来编译生成zxing的Jar包。下载源码zxing新建Module在IDEA中新建Module，并把zxing的core源码拷贝进去，javase的源码也要拷贝进去编译Jar包打开Project Structure，选择Artifacts，选择相应的Path，勾选上Include In Project，如图所示：最后右键zxing这个Module，选择build即可在相应的Path下找到编译好的Jar包生成二维码1234567891011121314151617181920public static void WriteQRcode(String content, File file) &#123; try &#123; MultiFormatWriter multiFormatWriter = new MultiFormatWriter(); int width = 400; int height = 400; Map hints = new HashMap(); hints.put(EncodeHintType.CHARACTER_SET, "UTF-8"); BitMatrix bitMatrix = multiFormatWriter.encode(content, BarcodeFormat.QR_CODE, width, height, hints); Path path = file.toPath(); MatrixToImageWriter.writeToPath(bitMatrix, "jpg", path); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;识别二维码123456789101112131415161718192021222324252627public static void ReadQRcode(File file) &#123; try &#123; MultiFormatReader multiFormatReader = new MultiFormatReader(); BufferedImage image = ImageIO.read(file); LuminanceSource source = new BufferedImageLuminanceSource(image); Binarizer binarizer = new HybridBinarizer(source); BinaryBitmap binaryBitmap = new BinaryBitmap(binarizer); Map hints = new HashMap(); hints.put(EncodeHintType.CHARACTER_SET, "UTF-8"); Result result = multiFormatReader.decode(binaryBitmap, hints); System.out.println("result: " + result.toString()); System.out.println("resultFormat: " + result.getBarcodeFormat()); System.out.println("resultText: " + result.getText()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Hexo完美兼容LeTeX公式]]></title>
    <url>%2F2017%2F08%2F03%2Ff1692270-16e2-44fb-88f3-6df2b4644f24%2F</url>
    <content type="text"><![CDATA[Hexo中的Markdown对于大部分的公式都可以渲染成功，然而对于部分公式，由于Markdown语法和LeTeX语法有冲突，因此造成部分公式内容被marked先转义，导致公式渲染失败，经过权衡，决定放弃部分Markdown功能，确保LeTeX的正确。该冲突主要是由于对\和_的转义造成的。找到marked脚本文件C:\Users\maple\AppData\Roaming\npm\node_modules\hexo\node_modules\marked\lib\marked.js，先备份一下，然后修改1escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,修改为：1escape: /^\\([`*\[\]()# +\-.!_&gt;])/,1return '&lt;em&gt;' + text + '&lt;/em&gt;';修改为：1return '_' + text + '_';经测试，我需要用到的所有公式都可以显示，且未发现Markdown有明显变化。说明此种方法切实可行。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全错位排列]]></title>
    <url>%2F2017%2F07%2F30%2Fb9ed53a1-9a52-48f8-9033-d6d8834d6095%2F</url>
    <content type="text"><![CDATA[这里介绍全错位排列的两种解法，分别是利用递推公式和容斥原理递推公式假设排列是1,2,3···n个数，$D_n$表示n个数的全错位排列的方法数。$D_1$ = 0、$D_2$ = 1那么对于第1个位置，假设由k去占。现在就有两种情况：1和k互换了位置，k占1的位置，1占k的位置：那么此时相当于1和k位置确定，只需要讨论$D_{n-2}$的排列数。1没有占k的位置，而是占了其它的位置：那么此时相当于只确定了k的位置，需要讨论$D_{n-1}$的排列数。但是有（n-1）个数需要讨论，所以可以得到下面的递推式：$D_n = (n-1)(D_{n-1} + D_{n-2})$然后展开递推式就可以得到错位排序的通项公式了。容斥原理记$N(a_1,a_2,···,a_n)$为n个数都没排错的方法数，那么对于以下情况，可以得到一些结论：$a_1$排对，记$N(a_1) = (n-1)!$。因为a1已经排对了，那么还剩下(n-1)个位置让其它数排，所以有(n-1)!的排法。$a_1$、$a_2$排对，记$N(a_1,a_2) = (n-2)!$$a_1$、$a_2$、$a_3$排对，记$N(a_1,a_2,a_3) = (n-3)!$···$a_1$、$a_2$、$a_3$,$\dots$,$a_n$排对，记$N(a_1,a_2,a_3) = (n-n)! = 0! = 1$推广一下，对于任意t个数，可得下面的等式：$$\sum N(t) = \sum N(a_{i_1},a_{i_2},\dots,a_{i_t})! = \binom{n}{t}(n-t)$$所以：$$D_n = n! - \sum N(1) + \sum N(2) + \dots + (-1)^n\sum N(n)$$$$D_n = n!(1 - \frac{1}{1!} + \frac{1}{2!} + \dots + (-1)^n\frac{1}{n!})$$]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ClassLoader 介绍]]></title>
    <url>%2F2017%2F06%2F20%2Fa2ce4e4f-23d5-4823-9947-3b3be9e5d8a6%2F</url>
    <content type="text"><![CDATA[ClassLoader介绍什么是ClassLoader?一个Java程序，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。Java默认提供的三个ClassLoaderBootStrap ClassLoader：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，Extension ClassLoader：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。App ClassLoader：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。注意：除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。ClassLoader的加载原理原理介绍ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。双亲委托模型双亲委托模型这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。JVM如何判定两个class相同JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。ClassLoader的体系架构：URLClassLoader首先介绍下URLClassLoader的简单用法，下面是我搜索资料的得出一些简单用法。12345678910111213public static void main(String[] args) throws MalformedURLException &#123; File file = new File("D:\\priv\\alanice\\learning\\other\\Secret.class"); URL url = file.toURI().toURL(); System.out.println(url); URLClassLoader loader = new URLClassLoader(new URL[]&#123;url&#125;, Thread.currentThread().getContextClassLoader()); try &#123; Class c = loader.loadClass("priv.alanice.learning.other.Secret"); System.out.println(ObjectMethodAnalyzer.toString(c)); &#125; catch (ClassNotFoundException e) &#123; System.out.println("Secret not found!"); e.printStackTrace(); &#125;&#125;可惜的是这个没跑通，显示ClassNotFound，不知道具体是什么原因，难道必须把class打包成jar才能用吗？希望在以后的学习里能了解更深入点。自定义ClassLoader前文提到我们可以通过继承ClassLoader或者URLClassLoader来自定义我们自己的ClassLoader，这里我们就实现一个加载一个被加密的class文件。这里有用到之前写过的加密模块Java加密工具编写自己的类加载器，只需要继承ClassLoader类，然后覆盖findClass(String name)方法。ClassLoader超类的loadClass方法用于将类的加载操作委托给其父类加载器去进行，只有当该类尚未加载并且父类加载器也无法加载该类时，才调用findClass方法。如果要实现findClass方法，必须要做到以下两点:为来自本地文件系统或者其他来源的类加载器提供字节码（解密工作就在这里进行）调用ClassLoader超类的definClass方法，向虚拟机提供字节码注意：调用ClassLoader的loadClass方法时需要指定完整的包名和类名，否则会出错。下面是一个简单的demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.net.MalformedURLException;public class SecretClassLoader extends ClassLoader &#123; private String key; public void setKey(String k) &#123; key = k; &#125; public SecretClassLoader(String k) &#123; key = k; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] classBytes = loadClassBytes(name); Class&lt;?&gt; c = defineClass(name, classBytes, 0, classBytes.length); if (c == null) throw new ClassNotFoundException(name); return c; &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name); &#125; &#125; private byte[] loadClassBytes(String name) throws IOException &#123; String cname = "out/production/Learning-Java/" + name.replace('.', '/') + ".secret"; FileInputStream fis = new FileInputStream(cname); ByteArrayOutputStream baos = new ByteArrayOutputStream(); CryptoCipher.decode(fis, baos, key); byte[] bytes = baos.toByteArray(); fis.close(); baos.close(); return bytes; &#125; public static void main(String[] args) throws MalformedURLException &#123; SecretClassLoader loader = new SecretClassLoader("0ZRmCCkKnd4eO/QoU8X0uA=="); try &#123; Class c = loader.loadClass("priv.alanice.learning.other.Secret"); SecretInterface s = (SecretInterface) c.newInstance(); System.out.println(s.secretMethod("Alan")); &#125; catch (ClassNotFoundException e) &#123; System.out.println("Secret not found!"); e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java加密类]]></title>
    <url>%2F2017%2F06%2F15%2Fa51c6b72-53d3-4f6b-8bfb-825bd66c1183%2F</url>
    <content type="text"><![CDATA[Cipher类介绍此类为加密和解密提供密码功能。它构成了 Java Cryptographic Extension （JCE） 框架的核心。Cipher类是一个引擎类，它需要通过getInstance()工厂方法来实例化对象。为创建 Cipher 对象，应用程序调用 Cipher 的 getInstance 方法并将所请求转换 的名称传递给它。还可以指定提供者的名称（可选）。之后通过其init方法初始化它的模式 (加密 / 解密) ， update方法进行数据块的加密。例如：12Cipher cipher = Cipher.getInstance("AES");cipher.init(Cipher.ENCRYPT_MODE, key);生成秘钥Java的java.security算法内置了很多加密算法，比如AES，DES，RSA等。使用这些算法需要用专门的秘钥对象SecretKey。密钥生成可以使用KeyGenerator生成秘钥，保存这个秘钥的方式有3种：通过ObjectOutputStream把这个KeyGenerator保存下来；通过一般的OutputStream把秘钥的字节保存下来；把秘钥的字节进行BASE64处理成字符串；下面有一个简单实例。12345678public static String generateKey(final String Algorithm) throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(Algorithm); SecureRandom random = new SecureRandom(); keyGenerator.init(random); SecretKey key = keyGenerator.generateKey(); byte[] bytes = key.getEncoded(); return Base64.getEncoder().encodeToString(bytes);&#125;会生成形如0ZRmCCkKnd4eO/QoU8X0uA==的字符串文件的加解密Java内置的CipherOutputStream流可以对流对象进行自动加密解密，用起来很方便。但是我在使用的过程发现一个问题，就是文件的最后几个字节 (不足16字节的那部分) 可能存在丢失，所以我进行了小小的改进，当加密到文件的最后一个数据块时，调用cipher的doFinal方法，这样可以有效避免字节丢失问题。具体实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import javax.crypto.*;import javax.crypto.spec.SecretKeySpec;import java.io.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Base64;public class CryptoCipher &#123; private static final int ENCRYPT_MODE = Cipher.ENCRYPT_MODE; private static final int DECRYPT_MODE = Cipher.DECRYPT_MODE; private static final int BLOCK_SIZE = 1024; public static String generateKey(final String Algorithm) throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(Algorithm); SecureRandom random = new SecureRandom(); keyGenerator.init(random); SecretKey key = keyGenerator.generateKey(); byte[] bytes = key.getEncoded(); return Base64.getEncoder().encodeToString(bytes); &#125; private static void Encode_Decode(final int MODE,InputStream is, OutputStream os, String keyStr) &#123; try &#123; byte[] bytes = Base64.getDecoder().decode(keyStr); SecretKey key = new SecretKeySpec(bytes, "AES"); Cipher cipher = Cipher.getInstance("AES"); cipher.init(MODE, key); CipherOutputStream out = new CipherOutputStream(os, cipher); byte[] buff = new byte[BLOCK_SIZE]; int length; while ((length = is.read(buff)) != -1) &#123; if (length == BLOCK_SIZE) out.write(buff, 0, length); else &#123; byte[] finalBytes = cipher.doFinal(buff, 0, length); os.write(finalBytes); &#125; &#125; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; &#125; public static void encode(InputStream is, OutputStream os, String keyStr) &#123; Encode_Decode(ENCRYPT_MODE, is, os, keyStr); &#125; public static void decode(InputStream is, OutputStream os, String keyStr) &#123; Encode_Decode(DECRYPT_MODE, is, os, keyStr); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java动态代理]]></title>
    <url>%2F2017%2F06%2F12%2F19bab8c9-de39-4078-9d5b-116ad90f994f%2F</url>
    <content type="text"><![CDATA[Java动态代理介绍代理模式是常用的java设计模式，它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。代理模式上，基本上有Subject角色，RealSubject角色，Proxy角色。其中：Subject角色负责定义RealSubject和Proxy角色应该实现的接口；RealSubject角色用来真正完成业务服务功能；Proxy角色负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。代理类处理的逻辑很简单：在调用某个方法前及方法后做一些额外的业务。换一种思路就是：在触发（invoke）真实角色的方法之前或者之后做一些额外的业务。那么，为了构造出具有通用性和简单性的代理类，可以将所有的触发真实角色动作交给一个触发的管理器，让这个管理器统一地管理触发。JDK方式实现动态代理JDK为RealSubject对象创建动态代理对象，主要做了以下工作：获取RealSubject上的所有接口列表。确定要生成的动态代理类的类名，默认为com.sun.proxy.$ProxyXXX根据需要实现接口信息，在代码中动态创建该Proxy的字节码将对应的字节码转换为对应的class对象创建InvocationHandler实例，用来处理Proxy所有方法调用Proxy的class对象以创建的handler对象为参，实例化Proxy对象JDK通过java.lang.reflect.Proxy来支持动态代理，一般情况下，使用方法newProxyInstanceof来创建Proxy类，而对于InvocationHandler，需要实现它的invoke方法，在调用代理对象中的每一个方法时，在代码内部，都是直接调用了InvocationHandler的invoke方法，而invoke方法根据代理类传递给自己的method参数来区分是什么方法。实例如下：Download.java123public interface Downloader &#123; public void downloadImage(String imageURL, String filename) throws Throwable;&#125;Subject.java12345678910111213141516171819import java.io.*;import java.net.URL;import java.net.URLConnection;public class Subject implements Downloader &#123; public void downloadImage(String imageURL, String filename) throws Throwable &#123; System.out.println("Downloading image from " + imageURL + " to " + filename + "..."); URL url = new URL(imageURL); URLConnection con = url.openConnection(); BufferedInputStream bis = new BufferedInputStream(con.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filename)); byte[] buff = new byte[4096]; int length; while ((length = bis.read(buff)) != -1) &#123; bos.write(buff, 0, length); &#125; bis.close(); bos.close(); &#125;&#125;ProxyHander.java12345678910111213141516import java.lang.reflect.*;public class ProxyHander implements InvocationHandler &#123; private Object proxiedObj; public ProxyHander(Object obj) &#123; super(); proxiedObj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long start = System.currentTimeMillis(); Object result = method.invoke(proxiedObj, args); long end = System.currentTimeMillis(); System.out.println(method.getName() + " cost " + (end - start) + " ms..."); return result; &#125;&#125;Main.java12345678import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) throws Throwable &#123; ProxyHander proxyHander = new ProxyHander(new Subject()); Downloader proxy = (Downloader) Proxy.newProxyInstance(Subject.class.getClassLoader(), Subject.class.getInterfaces(), proxyHander); proxy.downloadImage("http://202.114.96.204/cache/9/04/cankaoxiaoxi.com/df328181a0da90521ad4da4ad30f8d35/1496884353332.jpg", "image.jpg"); &#125;&#125;输出结果12Downloading image from http://202.114.96.204/cache/9/04/cankaoxiaoxi.com/df328181a0da90521ad4da4ad30f8d35/1496884353332.jpg to image.jpg...downloadImage cost 125 ms...cglib实现动态代理JDK中提供的生成动态代理类的机制有个鲜明的特点是： 某个类必须有实现的接口，而生成的代理类也只能代理某个类接口定义的方法，果某个类没有实现接口，那么这个类就不能同JDK产生动态代理了！CGLIB（Code Generation Library），是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。cglib 创建某动态代理类的模式是：查找类上的所有非final的public类型的方法定义将这些方法的定义转换成字节码将组成的字节码转换成相应的代理的class对象实现MethodInterceptor接口，用来处理对代理类上所有方法的请求（和InvocationHandler的功能和角色是一样的）实例如下：Subject.java12345678910111213141516171819import java.io.*;import java.net.URL;import java.net.URLConnection;public class Subject &#123; public void downloadImage(String imageURL, String filename) throws IOException &#123; System.out.println("Downloading image from " + imageURL + " to " + filename + " ..."); URL url = new URL(imageURL); URLConnection con = url.openConnection(); BufferedInputStream bis = new BufferedInputStream(con.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filename)); byte[] buff = new byte[4096]; int length; while ((length = bis.read(buff)) != -1) &#123; bos.write(buff, 0, length); &#125; bis.close(); bos.close(); &#125;&#125;SubjectEnhancer.java12345678910111213import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class SubjectEnhancer implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; long start = System.currentTimeMillis(); Object result = methodProxy.invokeSuper(o, objects); long end = System.currentTimeMillis(); System.out.println(method.getName() + " cost " + (end - start) + " ms..."); return result; &#125;&#125;SubjectInterceptor.java12345678910111213import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class SubjectInterceptor implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; long start = System.currentTimeMillis(); Object result = methodProxy.invokeSuper(o, objects); long end = System.currentTimeMillis(); System.out.println(method.getName() + " cost " + (end - start) + " ms..."); return result; &#125;&#125;Main.java1234567import java.io.IOException;public class Main &#123; public static void main(String[] args) throws IOException &#123; Subject subject = ProxyFactory.getInstance(new SubjectInterceptor(), Subject.class); subject.downloadImage("http://202.114.96.204/cache/9/04/cankaoxiaoxi.com/df328181a0da90521ad4da4ad30f8d35/1496884353332.jpg", "image.jpg"); &#125;&#125;输出结果12Downloading image from http://202.114.96.204/cache/9/04/cankaoxiaoxi.com/df328181a0da90521ad4da4ad30f8d35/1496884353332.jpg to image.jpg ...downloadImage cost 219 ms...]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配算法]]></title>
    <url>%2F2017%2F06%2F10%2Ffb43a7b4-88c2-4fe6-9c1b-aea85ab6dd7b%2F</url>
    <content type="text"><![CDATA[KMP算法算法介绍KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。KMP算法中，对于每一个模式串我们会事先计算出模式串的内部匹配信息，在匹配失败时最大的移动模式串，以减少匹配次数。比如，在简单的一次匹配失败后，我们会想将模式串尽量的右移和主串进行匹配。右移的距离在KMP算法中是如此计算的：在已经匹配的模式串子串中，找出最长的相同的前缀和后缀，然后移动使它们重叠。算法实现123456789101112131415161718192021222324public static int KMPSearch(String target, String pattern) &#123; int[] nextVal = getNextVal(pattern); int i = 0, j = 0, N = target.length(), M = pattern.length(); while (i &lt; N &amp;&amp; j &lt; M) &#123; if (j == -1 || target.charAt(i) == pattern.charAt(j)) &#123; i++; j++; &#125; else j = nextVal[j]; &#125; if (j &gt;= M) return i - M; return -1;&#125;private static int[] getNextVal(String pattern) &#123; int[] nextVal = new int[pattern.length()]; nextVal[0] = -1; int i = 0, j = -1; int M = pattern.length() - 1; while (i &lt; M) &#123; if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) &#123; i++; j++; if (pattern.charAt(i) == pattern.charAt(j)) nextVal[i] = nextVal[j]; else nextVal[i] = j; &#125; else j = nextVal[j]; &#125; return nextVal;&#125;BM算法算法介绍Boyer-Moore充分使用预处理P的信息来尽可能跳过更多的字符。通常，我们比较一个字符串都是从首字母开始，逐个比较下去。一旦发现有不同的字符，就需要从头开始进行下一次比较。这样，就需要将字串中的所有字符一一比较。Boyer-Moore算法的关键在于，当P的最后一个字符被比较完成后，我们可以决定跳过一个或更多个字符。如果最后一个字符不匹配，那么就没必要继续比较前一个字符。如果最后一个字符未在P中出现，那么我们可以直接跳过T的n个字符，比较接下来的n个字符，n为P的长度（见定义）。如果最后一个字符出现在P中，那么跳过的字符数需要进行计算（也就是将P整体往后移），然后继续前面的步骤来比较。通过这种字符的移动方式来代替逐个比较是这个算法如此高效的关键所在。算法实现123456789101112131415161718192021public static int BMSearch(String target, String pattern) &#123; int[] right = getRight(pattern); int N = target.length(), M = pattern.length(), skip = 0; for (int i = 0; i &lt;= N - M; i += skip) &#123; skip = 0; for (int j = M - 1; j &gt;= 0; j--) if (pattern.charAt(j) != target.charAt(i + j)) &#123; skip = j - right[target.charAt(i + j)]; break; &#125; if (skip == 0) return i; &#125; return -1;&#125;private static int[] getRight(String pattern) &#123; int[] right = new int[256]; int M = pattern.length(); for (int i = 0; i &lt; 256; i++) right[i] = -1; for (int i = 0; i &lt; M; i++) right[pattern.charAt(i)] = i; return right;&#125;RK算法算法介绍如果两个字符串hash后的值不相同，则它们肯定不相同；如果它们hash后的值相同，它们不一定相同。RK算法的基本思想就是：将模式串P的hash值跟主串S中的每一个长度为|P|的子串的hash值比较。如果不同，则它们肯定不相等；如果相同，则再诸位比较之。~~算法实现 (有问题，按书上敲的，但是结果不对) ~~12345678910111213141516171819202122232425public static int RKSearch(String target, String pattern) &#123; int N = target.length(), M = pattern.length(); int R = 256, Q = 997, RM = 1; for (int i = 1; i &lt; M; i++) RM = (R * RM) % Q; long patternHash = hash(pattern, M, R, Q); long targetHash = hash(target, M, R, Q); if (patternHash == targetHash &amp;&amp; check(target, pattern, 0)) return 0; for (int i = M; i &lt; N; i++) &#123; // 减去最前面的hash，加上最后面的hash targetHash = (targetHash + Q - RM * targetHash * target.charAt(i - M) % Q) % Q; targetHash = (targetHash * R + target.charAt(i)) % Q; if (targetHash == patternHash &amp;&amp; check(target, pattern, i - M + 1)) return i - M + 1; &#125; return -1;&#125;private static long hash(String key, int M, int R, int Q) &#123; long h = 0; for (int i = 0; i &lt; M; i++) h = (R * h + key.charAt(i)) % Q; return h;&#125;private static boolean check(String target, String pattern, int i) &#123; return pattern.equals(target.substring(i, i + pattern.length()));&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 Tips]]></title>
    <url>%2F2017%2F06%2F07%2Fefa3a000-8619-4b89-a5ba-852aa1217b86%2F</url>
    <content type="text"><![CDATA[Win10 右键新建菜单1234567Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Discardable\PostSetup\ShellNew]&quot;Classes&quot;=hex(7):2e,00,74,00,78,00,74,00,00,00,2e,00,64,00,6f,00,63,00,78,00,\ 00,00,2e,00,70,00,70,00,74,00,78,00,00,00,2e,00,78,00,6c,00,73,00,78,00,00,\ 00,46,00,6f,00,6c,00,64,00,65,00,72,00,00,00,00,00&quot;~reserved~&quot;=hex:08,00,00,00,00,00,06,00清除图标缓存1234567891011121314151617181920taskkill /f /im explorer.exeattrib -h -s -r "%userprofile%\AppData\Local\IconCache.db"del /f "%userprofile%\AppData\Local\IconCache.db"attrib /s /d -h -s -r "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\*"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_32.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_96.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_102.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_256.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_1024.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_idx.db"del /f "%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_sr.db"echo y|reg delete "HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify" /v IconStreamsecho y|reg delete "HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify" /v PastIconsStreamstart explorer图片打开方式添加默认图片查看器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Windows Registry Editor Version 5.00; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.jpg]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.jpeg]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.gif]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.png]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.bmp]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.pcx]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.tiff]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;; Change Extension&apos;s File Type[HKEY_CURRENT_USER\Software\Classes\.ico]@=&quot;PhotoViewer.FileAssoc.Tiff&quot;Win10某一路径下打开文件夹总是打开新窗口打开注册表，定位到[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Modules\NavPane]。把NavPane这项删除，然后在原位置重建同名项。注销重登陆或重启（或者直接重启文件资源管理explorer.exe）后，就可以了。如果你有用过PhotoshopCC2015，它的“快速导出为png”也会造成的这个问题。你导出到哪个库文件夹，那个文件夹就会这样。可以在注册表的这一项上，加上禁止写入修改的权限，来防止这个问题。]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 配置]]></title>
    <url>%2F2017%2F06%2F04%2F506f9f0c-7d9c-4225-b93a-2850f1b68d92%2F</url>
    <content type="text"><![CDATA[Sublime-Text-3 Windows编译选项C++12345678910&#123; &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;], &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;shell&quot;: true, &quot;variants&quot;:[&#123; &quot;name&quot;: &quot;Run&quot;, &quot;cmd&quot;: [ &quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;.exe &amp;echo. &amp;pause&quot;] &#125;]&#125;Java12345678910&#123; &quot;cmd&quot;: [&quot;javac&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;, &quot;-d&quot;, &quot;.&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^(...*?):([0-9]*):?([0-9]*)&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;shell&quot;: true, &quot;variants&quot;: [&#123; &quot;name&quot;: &quot;Run&quot;, &quot;cmd&quot;: [&quot;javac&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;, &quot;-d&quot;, &quot;.&quot;, &quot;$file&quot;, &quot;&amp;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;java $&#123;file_base_name&#125; &amp;echo. &amp;pause&quot;] &#125;]&#125;Python123456&#123; &quot;cmd&quot;: [&quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;python $file &amp;echo. &amp;pause&quot;], &quot;file_regex&quot;: &quot;^(...*?):([0-9]*):?([0-9]*)&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;shell&quot;: true&#125;Sublime-Text-3 Ubuntu编译选项C++123456789&#123; &quot;shell_cmd&quot;: &quot;g++7 \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;variants&quot;: [&#123; &quot;name&quot;: &quot;Run&quot;, &quot;shell_cmd&quot;: &quot;g++7 \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp;&amp; gnome-terminal -x bash -c \&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;;echo;echo 按任意键继续...;read -n 1\&quot;&quot; &#125;]&#125;Java12345678&#123; &quot;shell_cmd&quot;: &quot;javac -encoding UTF-8 -d . $file&quot;, &quot;file_regex&quot;: &quot;^(...*?):([0-9]*):?([0-9]*)&quot;, &quot;variants&quot;: [&#123; &quot;name&quot;: &quot;Run&quot;, &quot;shell_cmd&quot;: &quot;javac -encoding UTF-8 -d . $file &amp;&amp; gnome-terminal -x bash -c \&quot;java $&#123;file_base_name&#125;;echo;echo 按任意键继续...;read -n 1\&quot;&quot; &#125;]&#125;Python12345&#123; &quot;shell_cmd&quot;: &quot;gnome-terminal -x bash -c \&quot;python3 $file;echo;echo 按任意键继续...;read -n 1\&quot;&quot;, &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;&#125;Sublime-Text-3插件选项快捷键设置12345678[ &#123; &quot;keys&quot;: [&quot;ctrl+r&quot;], &quot;command&quot;: &quot;reindent&quot; , &quot;args&quot;:&#123;&quot;single_line&quot;: false&#125;&#125;, &#123; &quot;keys&quot;: [&quot;alt+m&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;alt+c&quot;], &quot;command&quot;: &quot;convert_to_utf8&quot;, &quot;args&quot;: &#123;&quot;encoding&quot;: &quot;UTF8&quot;, &quot;stamp&quot;: &quot;0&quot; &#125; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+alt+c&quot;], &quot;command&quot;: &quot;convert_to_utf8&quot;, &quot;args&quot;: &#123;&quot;encoding&quot;: &quot;GBK&quot;, &quot;stamp&quot;: &quot;0&quot; &#125; &#125;, &#123; &quot;keys&quot;: [&quot;alt+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;, &#123; &quot;keys&quot;: [&quot;ctrl+alt+j&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;]Markdown Preview12345&#123; &quot;enable_highlight&quot;: true, &quot;enable_mathjax&quot;: true, &quot;html_template&quot;: &quot;D:\\我的文档\\文档\\Ice\\学习\\Blog\\base.html&quot;&#125;Anaconda123&#123; &quot;anaconda_linting&quot;: false&#125;Ubuntu16.04下Sublime Text 3无法输入中文首先参考Github上的解决方案sublime-text-imfix为了使用鼠标右键打开文件时能够使用中文输入，还需要修改文件sublime_text.desktop的内容将[Desktop Entry]中的字符串Exec=/opt/sublime_text/sublime_text %F修改为Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F&quot;将[Desktop Action Window]中的字符串Exec=/opt/sublime_text/sublime_text -n修改为Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n&quot;将[Desktop Action Document]中的字符串Exec=/opt/sublime_text/sublime_text --command new_file修改为Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file&quot;]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS 开发环境配置]]></title>
    <url>%2F2017%2F06%2F01%2F37bc801c-f724-4136-a888-20679096101e%2F</url>
    <content type="text"><![CDATA[编译安装python3.4Centos上面默认的Python版本是2.6，本文介绍如何安装3.6版本。下载前准备需要安装以下库，不然会有问题。1yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make下载Python3.4源码1wget http://mirrors.sohu.com/python/3.6.1/Python-3.6.1.tar.xz解压缩并安装12345678910111213141516xz -d Python-3.4.1.tar.xztar xf Python-3.4.1.tar -C /usr/local/src/cd /usr/local/src/Python-3.4.1/./configure --prefix=/usr/local/python34make -j8 &amp;&amp; make install``` ## 配置vsftpd服务### 添加ftp用户首先添加ftp用户假设这里我们添加的用户名字叫ftpuser添加用户useradd -d /home/ftpuser -g ftpuser -s /sbin/nologin ftpuser设置密码psswd ftpuser1234### 配置文件最后贴一下我的配置文件，怕下次重新配置服务器ftp的时候又有问题Example config file /etc/vsftpd/vsftpd.conf#The default compiled in settings are fairly paranoid. This sample fileloosens things up a bit, to make the ftp daemon more usable.Please see vsftpd.conf.5 for all compiled in defaults.#READ THIS: This example file is NOT an exhaustive list of vsftpd options.Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd’scapabilities.#Allow anonymous FTP? (Beware - allowed by default if you comment this out).anonymous_enable=NO#Uncomment this to allow local users to log in.When SELinux is enforcing check for SE bool ftp_home_dirlocal_enable=YES#Uncomment this to enable any form of FTP write command.write_enable=YES#Default umask for local users is 077. You may wish to change this to 022,if your users expect that (022 is used by most other ftpd’s)local_umask=022#Uncomment this to allow the anonymous FTP user to upload files. This onlyhas an effect if the above global write enable is activated. Also, you willobviously need to create a directory writable by the FTP user.When SELinux is enforcing check for SE bool allow_ftpd_anon_write, allow_ftpd_full_access#anon_upload_enable=YES#Uncomment this if you want the anonymous FTP user to be able to createnew directories.#anon_mkdir_write_enable=YES#Activate directory messages - messages given to remote users when theygo into a certain directory.dirmessage_enable=YES#Activate logging of uploads/downloads.xferlog_enable=YES#Make sure PORT transfer connections originate from port 20 (ftp-data).connect_from_port_20=YES#If you want, you can arrange for uploaded anonymous files to be owned bya different user. Note! Using “root” for uploaded files is notrecommended!#chown_uploads=YES#chown_username=whoever#You may override where the log file goes if you like. The default is shownbelow.#xferlog_file=/var/log/xferlog#If you want, you can have your log file in standard ftpd xferlog format.Note that the default log file location is /var/log/xferlog in this case.xferlog_std_format=YES#You may change the default value for timing out an idle session.#idle_session_timeout=600#You may change the default value for timing out a data connection.#data_connection_timeout=120#It is recommended that you define on your system a unique user which theftp server can use as a totally isolated and unprivileged user.#nopriv_user=ftpsecure#Enable this and the server will recognise asynchronous ABOR requests. Notrecommended for security (the code is non-trivial). Not enabling it,however, may confuse older FTP clients.#async_abor_enable=YES#By default the server will pretend to allow ASCII mode but in fact ignorethe request. Turn on the below options to have the server actually do ASCIImangling on files when in ASCII mode.Beware that on some FTP servers, ASCII support allows a denial of serviceattack (DoS) via the command “SIZE /big/file” in ASCII mode. vsftpdpredicted this attack and has always been safe, reporting the size of theraw file.ASCII mangling is a horrible feature of the protocol.#ascii_upload_enable=YES#ascii_download_enable=YES#You may fully customise the login banner string:#ftpd_banner=Welcome to blah FTP service.#You may specify a file of disallowed anonymous e-mail addresses. Apparentlyuseful for combatting certain DoS attacks.#deny_email_enable=YES(default follows)#banned_email_file=/etc/vsftpd/banned_emails#You may specify an explicit list of local users to chroot() to their homedirectory. If chroot_local_user is YES, then this list becomes a list ofusers to NOT chroot().(Warning! chroot’ing can be very dangerous. If using chroot, make sure thatthe user does not have write access to the top level directory within thechroot)chroot_local_user=YES#chroot_list_enable=YES(default follows)#chroot_list_file=/etc/vsftpd/chroot_list#You may activate the “-R” option to the builtin ls. This is disabled bydefault to avoid remote users being able to cause excessive I/O on largesites. However, some broken FTP clients such as “ncftp” and “mirror” assumethe presence of the “-R” option, so there is a strong case for enabling it.#ls_recurse_enable=YES#When “listen” directive is enabled, vsftpd runs in standalone mode andlistens on IPv4 sockets. This directive cannot be used in conjunctionwith the listen_ipv6 directive.listen=NO#This directive enables listening on IPv6 sockets. By default, listeningon the IPv6 “any” address (::) will accept connections from both IPv6and IPv4 clients. It is not necessary to listen on _both_ IPv4 and IPv6sockets. If you want that (perhaps because you want to listen on specificaddresses) then you must run two copies of vsftpd with two configurationfiles.Make sure, that one of the listen options is commented !!listen_ipv6=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YESallow_writeable_chroot=YES```]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Tips]]></title>
    <url>%2F2017%2F06%2F01%2F22e63bec-2cca-4e1b-aca9-0c890e5444d4%2F</url>
    <content type="text"><![CDATA[清除Ubuntu的Application缓存1rm ~/.local/share/applications/sublime_text.desktop设置RTC时间在安装Ubuntu双系统的情况下，Ubuntu的时间总会和Windows的时间相差8小时，原因在于widows认为BIOS时间是本地时间，Ubuntu认为BIOS时间是UTC时间，这样从Ubuntu重启到ubuntu会发现时间相差8小时，Ubuntu会经常与NTP服务器时间进行同步，但Windows不会。所以我们需要将Ubuntu的时间改成本地时间，更改方法是执行1timedatectl set-local-rtc 1 --adjust-system-clockUbuntu /boot 分区不足解决方案经常升级系统，出现了上图的提示，解决办法：查看已安装的linux-image各版本1dpkg --get-selections | grep linux-image查看当前使用的linux-image各版本1uname -a一般使用的都是最新版，但保险起见，确认下。卸载linux-image各版本1sudo apt-get purge linux-image-4.4.0-75-generic使用purge卸载4.4.0-75，若使用remove卸载则会有类似4.4.0-75的遗留。再次查看已安装的linux-image各版本再次运行dpkg --get-selections | grep linux-image查看情况卸载完后可以用df命令看下boot分区的空间使用情况。1df -h善后工作对于图中因使用remove命令而残留的deinstall的，使用sudo dpkg -P linux-image-extra-4.4.0-75-generic]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu开发环境配置]]></title>
    <url>%2F2017%2F06%2F01%2F03c60658-1ecf-40b9-94da-8c1cf7f496f0%2F</url>
    <content type="text"><![CDATA[编译安装gcc6.2.0在archlinx的下gcc已经更新到6.2.1了，win10的WSL下还是gcc4.8。官方源没有比较新的版本，于是自己编译使用。GCC6的几个新特性GCC 6 现在的默认值是 C++ 14. GCC 6 现在包括 C++ Concepts.C++运行时库现在支持特殊的数学函数 (ISO/IEC 29124:2010)支持 C++17 的实验功能准备可以去gnu官网下载gcc6.2.0的源码，但国内访问速度比较慢。可以进中科大的镜像站去下载。下载并解压12wget http://mirrors.ustc.edu.cn/gnu/gcc/gcc-6.2.0/gcc-6.2.0.tar.bz2tar -xjvf gcc-6.2.0.tar.bz2解压之后进入源码目录，运行下面命令下载依赖包1./contrib/download_prerequisites #必须在源码根目录下运行此命令编译gcc前需安装build-essential,bison,flex,texinfo。生成Makefile在源码目录下建立一个build目录(也可以在别的目录下)，然后进入build目录运行configure脚本生成Makefile文件。123456mkdir build &amp;&amp; cd build../configure --prefix=/usr/local/gcc6 --enable-checking=release --enable-languages=c,c++ --enable-threads=posix --disable-multilib# --prefix=/usr/local/gcc6 指定安装路径# --enable-languages=c,c++ 支持的编程语言# --enable-threads=posix 使用POSIX/Unix98作为线程支持库# --disable-multilib 取消多目标库编译(取消32位库编译)下面是archlinux自带gcc的编译配置命令。1--prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++ --enable-shared --enable-threads=posix --enable-libmpx --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --disable-multilib --disable-werror --enable-checking=release编译安装上一步生成Makefile没有问题后，就可以直接编译安装了。12make -j8 #使用8个线程并行编译make install #安装(可能需要root权限)生成软链接12cd /usr/local/binln -s /usr/local/gcc6/bin/gcc gcc6Ubuntu16.04编译安装Python3.6安装tcl/tk和Tkintertcl和tk的下载地址：https://sourceforge.net/projects/tcl/files/Tcl/目前我下载的tcl/tk源代码包是 tcl8.6.6-src.tar.gz 和 tk8.6.6-src.tar.gz安装tcl8.6：12345tar -xzvf tcl8.6.6-src.tar.gz cd tcl8.6.6/unix./configuremakesudo make install安装tk8.6（与tcl8.6的安装相似）:编译时如果出现以下错误信息：123/home/alan/Downloads/tk8.6.6/unix/../generic/tk.h:96:25: 致命错误： X11/Xlib.h：没有那个文件或目录 编译中断。make: *** [tk3d.o] 错误 1那么说明x11库依赖缺失，在终端运行：1sudo apt-get install libx11-dev之后修改Setup.dist文件，进入python安装包解压后那个文件夹里， 命令打开Setup.dist文件vim Modules/Setup.dist修改上面5处地方， 把她们前面的＃删除掉， 默认的tcl和tk是8.2, 但是我们已经安装的tcl和tk的版本是8.6, 那么我们就将这里的tk8.3和tcl8.2修改为tk8.6和tcl8.6, 保存退出。配置ssl模块安装SSL相关的依赖12apt-get install opensslapt-get libssl-dev修改Setup.dist文件编译安装现在重装python3.6.0， 用以下命令一次性完成配置、编译、安装：123./configuremakesudo make installdeb包安装MySQLUbuntu下如果apt-get安装MySQL的话，仓库版本可能比较陈旧，所以我选择从官网下载deb包安装最新的MySQL下载MySQL到mysql网站下载相应的mysql安装包，我的mysql-server_5.7.17-1ubuntu16.04_amd64.deb-bundle.tar解压1tar -xvf mysql-server_5.7.17-1ubuntu16.04_amd64.deb-bundle.tar得到以下文件：libmysqlclient20_5.7.17-1ubuntu16.04_amd64.deblibmysqlclient-dev_5.7.17-1ubuntu16.04_amd64.deblibmysqld-dev_5.7.17-1ubuntu16.04_amd64.debmysql-client_5.7.17-1ubuntu16.04_amd64.debmysql-common_5.7.17-1ubuntu16.04_amd64.debmysql-community_5.7.17-1ubuntu16.04_amd64.changesmysql-community-client_5.7.17-1ubuntu16.04_amd64.debmysql-community-server_5.7.17-1ubuntu16.04_amd64.debmysql-community-source_5.7.17-1ubuntu16.04_amd64.debmysql-community-test_5.7.17-1ubuntu16.04_amd64.debmysql-server_5.7.17-1ubuntu16.04_amd64.debmysql-server_5.7.17-1ubuntu16.04_amd64.deb-bundle.tarmysql-testsuite_5.7.17-1ubuntu16.04_amd64.debsan安装所需的包123456789101112sudo dpkg -i mysql-common_5.7.16-1ubuntu16.04_amd64.debsudo dpkg-preconfigure mysql-community-server_5.7.16-1ubuntu16.04_amd64.debsudo dpkg -i libmysqlclient20_5.7.16-1ubuntu16.04_amd64.debsudo dpkg -i libmysqlclient-dev_5.7.16-1ubuntu16.04_amd64.debsudo dpkg -i libmysqld-dev_5.7.16-1ubuntu16.04_amd64.debsudo apt-get install libaio1sudo dpkg -i mysql-community-client_5.7.16-1ubuntu16.04_amd64.deb sudo dpkg -i mysql-client_5.7.16-1ubuntu16.04_amd64.debsudo dpkg -i mysql-common_5.7.16-1ubuntu16.04_amd64.debsudo apt-get install libmecab2sudo dpkg -i mysql-community-server_5.7.16-1ubuntu16.04_amd64.debsudo dpkg -i mysql-server_5.7.16-1ubuntu16.04_amd64.deb其他库依赖的安装安装readline库1sudo apt-get install libreadline-dev安装zlib库1sudo apt-get install zlib1g-dev]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 装饰器]]></title>
    <url>%2F2017%2F05%2F30%2F88cf2162-db36-4ac6-a6d0-56fc08d906b3%2F</url>
    <content type="text"><![CDATA[装饰器设计模式装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。在Python中，使用@语法糖修饰一个函数，把@deco放到func()函数的定义处，相当于执行了语句：1func = deco(func)不带参数的装饰器123456789def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print(time.strftime('%Y-%m-%d',time.localtime(time.time())))输出结果：12call now():2017-06-19带参数的装饰器12345678910def log(text): def decorator(func): def wrapper(*args, **kw): print('%s call %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log(‘Alan’)def now():print(time.strftime(‘%Y-%m-%d’,time.localtime(time.time())))输出结果：12Alan call now():2017-06-19]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 代码片段]]></title>
    <url>%2F2017%2F05%2F27%2F25cea738-3126-404e-bbc7-e53490d81e4c%2F</url>
    <content type="text"><![CDATA[从文件获得cookies123456cookies=&#123;&#125;with open(r'cookies.txt','r') as f: for line in f.read().split(';'): #其设置为1就会把字符串拆分成2份 name,value = line.strip().split('=', 1) cookies[name] = value爬取网页上的图片12345678910111213141516import urllib.requestimport redef getHtml(url): page = urllib.request.urlopen(url) html = page.read().decode('utf-8') return htmldef getImg(html): reg = r'src="(.+?\.jpg)" width' imgre = re.compile(reg) imglist = re.findall(imgre,html) x = 0 for imgurl in imglist: urllib.request.urlretrieve(imgurl,'images/%s.jpg' % x) x+=1html = getHtml('http://tieba.baidu.com/p/741081023')getImg(html)使用pymysql操纵MySQL123456789101112131415import pymysqltry: conn= pymysql.connect(host='localhost', port=3306, user='DBSAdmin', passwd='admin', charset='UTF8', db='dbs') cur=conn.cursor() #获取一个游标对象 cur.execute("INSERT INTO nameage VALUES('小明', 15),('小洪', 17),('小高', 16),('小刚', 15)")#插入数据 cur.execute("SELECT * FROM nameage") data=cur.fetchall() for row in data: print('%s\t%s' %row)except Exception as e: print("发生异常")finally: cur.close() #关闭游标 conn.commit() #向数据库中提交任何未解决的事务，对不支持事务的数据库不进行任何操作 conn.close() #关闭到数据库的连接，释放数据库资源]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL命令详解]]></title>
    <url>%2F2017%2F05%2F24%2F34bca71a-5342-46ae-8e97-eceb2be88545%2F</url>
    <content type="text"><![CDATA[用户权限类授予权限1GRANT privileges ON databasename.tablename TO 'username'@'host';privileges：用户的操作权限,如SELECT, INSERT , UPDATE等.如果要授予所的权限则使用ALLdatabasename：数据库名tablename：表名,如果要授予该用户对所有数据库和表的相应操作权限则可用_表示, 如_.*注意：用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:1GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;撤销权限1REVOKE privilege ON databasename.tablename FROM 'username'@'host';查看授予的权限1show grants for root@'localhost';删除用户DELETE FROM user Where User=’test’ AND Host=’localhost’;表结构变更类更改表名1234567alter table tablename rename tablenewname;``` ### 更改字段类型``` sqlalter table tablename modify column columnname typename;更改字段默认值1alter table tablename alter column columnname set default '';添加字段1alter table tablename add columnname varchar(10) not Null;查看和更改自增字段的值12select auto_increment from information_schema.tables where table_schema='db name' and table_name='table name';alter table tablename auto_increment=NUMBER;;数据存取类从数据库里随机读取几条数据1SELECT * FROM table order by rand() limit 20;数据库编码类创建UTF-8数据库1CREATE DATABASE dbname DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL密码重置]]></title>
    <url>%2F2017%2F05%2F24%2F61f2bf0b-e0f0-4d04-8490-19542beb2eab%2F</url>
    <content type="text"><![CDATA[停止数据库WIndows下CMD执行net stop mysql修改my.cnf利用文本编辑器打开mysql配置文件my.ini/my.cnf,在mysqld进程配置文件中添加skip-grant-tables。重启数据库WIndows下CMD执行net start mysql修改root密码重启数据库后可以不用密码直接登陆，执行mysql -p可以直接登陆进数据库。在mysql命令行下执行以下命令修改root密码：1update mysql.user set password=password('newpassword') where user='root'重启数据库密码修改完成后，将my.ini/my.cnf文件中添加的skip-grant-tables语句注释或删除掉，然后重启数据库即可]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装教程]]></title>
    <url>%2F2017%2F05%2F24%2F4d74d6f2-a0ce-4b59-ac0d-788d4a51561d%2F</url>
    <content type="text"><![CDATA[下载软件进入mysql官网，登陆自己的oracle账号，下载Mysql-5.7.14，下载地址：MySQL将下载好的文件解压到指定目录，笔者解压在C:\software\Mysql\mysql-5.7.14-winx64安装过程首先配置环境变量path，将C:\software\Mysql\mysql-5.7.14-winx64\bin配置到自己的path中。在解压路径下复制my-default.ini,修改名称为my.ini。打开文件my.ini,添加内容如下：1234[mysqld]basedir=C:\\software\Mysql\mysql-5.7.14-winx64datadir=C:\\software\Mysql\mysql-5.7.14-winx64\dataport=3306basedir:是上述mysql的解压路径datadir：后续初始化等数据都会保存在该目录下，在该文件目录下新建data文件夹port：表示连接数据库的端口号初始化数据库 配置相关信息以管理员身份运行windows 命令行,进入mysql的解压缩目录提醒：此处需要进入bin目录，否则后续操作会出现错误。执行进行初始化，运行命令：mysqld --initialize --user=mysql --console此时会生成root的初始密码，记住此时生成的初始化密码。安装Mysql服务。运行命令：mysqld --install MySQL此时，可以起动mysql服务，运行命令：net start mysql用户可能会出现如下错误：1. 发生系统错误 2. 系统找不到指定文件。错误原因：如上所述，在运行安装服务命令:mysqld --install MySQL时，我们没有进入bin目录，进行安装。解决方案：进入bin目录，首先移除service，运行命令 ：mysqld --remove,重新安装mysql服务，运行命令：mysqld --install登陆数据库命令行输入mysql -u root -p，错误描述：error 1045 （28000）解决方法：在my.ini文件中在[mysqld]后一行加入skip-grant-tables此时，关闭mysql服务，再重新启动。重新登陆， 不需输入密码，直接enter。输入use mysql选择mysql数据库,查询mysql数据库的user表：select * from user此时，我们发现密码字段的名称为authentication_string。有的可能会是password，根据你查询出来的结果为准。对表user执行update操作：1update user set authentication_string = password("*******") where user="root"操作成功。退出mysql,删除my.ini 文件中的skip-grant-tables ，重新启动mysql服务。启动成功。至此，mysql在windows中安装成功。修改密码进入数据库后输入use mysql 后，可能会报错，如下：错误描述：ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.解决方法：123SET PASSWORD = PASSWORD(‘your new password‘);ALTER USER ‘root‘@‘localhost‘ PASSWORD EXPIRE NEVER;flush privileges;完成以上三步退出再登，使用新设置的密码就行了。创建用户创建用户和数据库12CREATE USER 'username'@'host' IDENTIFIED BY 'password';create database dbname CHARACTER SET UTF8;username：你将创建的用户名host：指定该用户在哪个主机上可以登陆。如果是本地用户可用localhost；如果想让该用户可以从任意远程主机登陆,可以使用通配符%。password：该用户的登陆密码。密码可以为空，如果为空则该用户可以不需要密码登陆服务器。dbname：数据库名称授权1GRANT privileges ON databasename.tablename TO 'username'@'host'privileges：用户的操作权限，如SELECT , INSERT , UPDATE 等，如果要授予所的权限则使用ALL。databasename：数据库名tablename：表名如果要授予该用户对所有数据库和表的相应操作权限则可用_表示, 如_.*。注意：用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令：1GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;设置与更改用户密码1SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');如果是当前登陆用户用1SET PASSWORD = PASSWORD("newpassword");刷新权限表1FLUSH PRIVILEGES;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux基本命令介绍]]></title>
    <url>%2F2017%2F05%2F22%2Fa82fd693-646d-4522-b327-cb161857b654%2F</url>
    <content type="text"><![CDATA[永久修改主机名1[root@localhost ~]# hostnamectl set-hostname &lt;host-name&gt;把用户加入sudoers12[Alan@localhost etc]$ ls -al /etc/sudoers-r--r----- 1 root root 3530 Apr 20 12:50 /etc/sudoers首先将sudoers的权限改为6401[root@localhost etc]# chmod u+w sudoers然后编辑/etc/sudoers文件，找到1root ALL=(ALL) ALL然后在该行下面加一行1Alan ALL=(ALL) ALLAlan为要加入sudoers的用户修改完之后，保存退出，然后再将sudoers的权限该回去，不然的话，Alan第一次使用sudo命令时会提示123sudo: /etc/sudoers is mode 0640, should be 0440sudo: no valid sudoers sources found, quitting”[root@localhost etc]# chmod u-w sudoers之后Alan就可以很好的使用sudo命令了。usermod 命令详解1usermod [options] user_nameusermod命令修改系统帐户文件来反映通过命令行指定的变化选项(options)12345678910111213-a|--append ##把用户追加到某些组中，仅与-G选项一起使用 -c|--comment ##修改/etc/passwd文件第五段comment -d|--home ##修改用户的家目录通常和-m选项一起使用 -e|--expiredate ##指定用户帐号禁用的日期，格式YY-MM-DD -f|--inactive ##用户密码过期多少天后采用就禁用该帐号，0表示密码已过期就禁用帐号，-1表示禁用此功能，默认值是-1 -g|--gid ##修改用户的gid，改组一定存在-G|--groups ##把用户追加到某些组中，仅与-a选项一起使用 -l|--login ##修改用户的登录名称 -L|--lock ##锁定用户的密码 -m|--move-home ##修改用户的家目录通常和-d选项一起使用 -s|--shell ##修改用户的shell -u|--uid ##修改用户的uid，该uid必须唯一 -U|--unlock ##解锁用户的密码示例(Examples):1.新建用户test，密码test,另外添加usertest组123# useradd test # echo "test" | passwd --stdin test # groupadd usertest2.把test用户加入usertest组123# usermod -aG usertest test ##多个组之间用空格隔开 # id test uid=500(test) gid=500(test) groups=500(test),501(usertest)3.修改test用户的Home目录123# usermod -md /home/usertest # ls /home usertest4.修改用户名123# usermod -l urchin(新用户名称) test(原来用户名称) # id urchin uid=500(urchin) gid=500(test) groups=500(test),501(usertest)5.修改用户的shell12345# sed '$!d' /etc/passwd urchin:x:500:500::/home/usertest:/bin/bash # usermod -s /bin/sh urchin # sed -n '$p' /etc/passwd urchin:x:500:500::/home/usertest:/bin/sh6.修改用户的UID123# usermod -u 578 urchin (UID必须唯一) # id urchin uid=578(urchin) gid=500(test) groups=500(test),501(usertest)7.修改用户的GID1234#groupadd -g 578 test1 #usermod -g 578 urchin (578组一定要存在) #id urchin uid=578(urchin) gid=578(test1) groups=578(test1),501(usertest)注意(caution)：usermod不允许你改变正在线上的使用者帐号名称。当usermod用来改变userID,必须确认这名user没在电脑上执行任何程序123456789101112/etc/passwduser_name:x:uid:gid:commnet:home:shell/etc/shadowusername:passwd:lastchg:min:max:warn:inactive:expire:flag–用户名–密码–从1970年1月1日起到上次修改密码所经过的天数–密码再过几天可以被变更(0表示随时可以改变)–密码再过几天必须被变更(99999表示永不过期)–密码过期前几天提醒用户(默认为一周)–密码过期几天后帐号被禁用–从1970年1月1日算起，多少天后账号失效查看当前主机的IP和DNS1nmcli dev show]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript格式化日期]]></title>
    <url>%2F2017%2F05%2F18%2F288b62ec-9b2e-46de-96a5-83bce1eccca3%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125;调用：12var time1 = new Date().Format("yyyy-MM-dd");var time2 = new Date().Format("yyyy-MM-dd HH:mm:ss");]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JNA介绍以及简单使用]]></title>
    <url>%2F2017%2F05%2F15%2Fce76f575-a4a9-4747-a637-4ba45d396e3f%2F</url>
    <content type="text"><![CDATA[JNA介绍JNA（Java Native Access ）提供一组Java工具类用于在运行期动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native/JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。优点JNA可以让你像调用一般java方法一样直接调用本地方法。就和直接执行本地方法差不多，而且调用本地方法还不用额外的其他处理或者配置什么的，也不需要多余的引用或者编码，使用很方便。JNA描述JNA类库使用一个很小的本地类库sub 动态的调用本地代码。程序员只需要使用一个特定的java接口描述一下将要调用的本地代码的方法的结构和一些基本属性。这样就省了为了适配多个平台而大量的配置和编译代码。因为调用的都是JNA提供的公用jar 包中的接口。JNA简单使用JNA实现WINDOWS下全局鼠标键盘钩子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package jna_test; import com.sun.jna.platform.win32.*;import com.sun.jna.platform.win32.WinUser.*;import com.sun.jna.platform.win32.WinDef.HMODULE;import com.sun.jna.platform.win32.WinDef.LRESULT;import com.sun.jna.platform.win32.WinDef.WPARAM;import com.sun.jna.platform.win32.WinUser.HHOOK;import com.sun.jna.platform.win32.WinUser.KBDLLHOOKSTRUCT;import com.sun.jna.platform.win32.WinUser.LowLevelKeyboardProc;import com.sun.jna.win32.WinUser.Mouse.LowLevelMouseProc;import com.sun.jna.win32.WinUser.Mouse.MOUSEHOOKSTRUCT; public class MouseLLHook &#123; // 鼠标钩子函数里判断按键类型的常数 public static final int WM_LBUTTONUP = 514; public static final int WM_LBUTTONDOWN = 513; public static final int WM_RBUTTONUP = 517; public static final int WM_RBUTTONDOWN = 516; public static final int WM_MOUSEHWHEEL = 526; public static final int WM_MOUSEWHEEL = 522; public static final int WM_MOUSEMOVE = 512; static HHOOK mouseHHK,keyboardHHK;//鼠标、键盘钩子的句柄 static LowLevelMouseProc mouseHook;//鼠标钩子函数 static LowLevelKeyboardProc keyboardHook;//键盘钩子函数 // 安装钩子 static void setHook() &#123; HMODULE hMod = Kernel32.INSTANCE.GetModuleHandle(null); mouseHHK = User32.INSTANCE.SetWindowsHookEx(WinUser.WH_MOUSE_LL, mouseHook, hMod, 0); keyboardHHK = User32.INSTANCE.SetWindowsHookEx(WinUser.WH_KEYBOARD_LL, keyboardHook, hMod, 0); &#125; //卸载钩子 static void unhook() &#123; User32.INSTANCE.UnhookWindowsHookEx(keyboardHHK); User32.INSTANCE.UnhookWindowsHookEx(mouseHHK); &#125; public static void main(String[] args) &#123; keyboardHook = new LowLevelKeyboardProc() &#123; @Override //该函数参数的意思参考：http://msdn.microsoft.com/en-us/library/windows/desktop/ms644985(v=vs.85).aspx public LRESULT callback(int nCode, WPARAM wParam, KBDLLHOOKSTRUCT lParam) &#123; int w = wParam.intValue(); //按下alt键时w=.WM_SYSKEYDOWN; 按下其他大部分键时w=WinUser.WM_KEYDOWN if(w==WinUser.WM_KEYDOWN || w==WinUser.WM_SYSKEYDOWN) System.out.println("key down: vkCode = "+lParam.vkCode); else if(w==WinUser.WM_KEYUP || w==WinUser.WM_SYSKEYUP) System.out.println("key up: vkCode = "+lParam.vkCode); // 如果按下'q'退出程序，'q'的vkCode是81 if(lParam.vkCode==81) &#123; unhook(); System.err.println("program terminated."); System.exit(0); &#125; return User32.INSTANCE.CallNextHookEx(keyboardHHK, nCode, wParam, lParam.getPointer()); &#125; &#125;; mouseHook = new LowLevelMouseProc() &#123; @Override //该函数参数的意思参考：http://msdn.microsoft.com/en-us/library/windows/desktop/ms644986(v=vs.85).aspx public LRESULT callback(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT lParam) &#123; switch (wParam.intValue()) &#123; case WM_MOUSEMOVE: System.out.print("mouse moved:"); break; case WM_LBUTTONDOWN: System.out.print("mouse left button down:"); break; case WM_LBUTTONUP: System.out.print("mouse left button up"); break; case WM_RBUTTONUP: System.out.print("mouse right button up:"); break; case WM_RBUTTONDOWN: System.out.print("mouse right button down:"); break; case WM_MOUSEWHEEL: System.out.print("mouse wheel rotated:"); break; &#125; System.out.println("("+lParam.pt.x+","+lParam.pt.y+")"); return User32.INSTANCE.CallNextHookEx(mouseHHK, nCode, wParam, lParam.getPointer()); &#125; &#125;; System.out.println("press 'q' to quit."); setHook(); int result; MSG msg = new MSG(); // 消息循环 // 实际上while循环一次都不执行，这些代码的作用我理解是让程序在GetMessage函数这里阻塞，不然程序就结束了。 while ((result = User32.INSTANCE.GetMessage(msg, null, 0, 0)) != 0) &#123; if (result == -1) &#123; System.err.println("error in GetMessage"); unhook(); break; &#125; else &#123; User32.INSTANCE.TranslateMessage(msg); User32.INSTANCE.DispatchMessage(msg); &#125; &#125; unhook(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring对Hibernate配置]]></title>
    <url>%2F2017%2F05%2F10%2F7286b193-5beb-4bf3-b8b1-90a56f5e40a9%2F</url>
    <content type="text"><![CDATA[spring对hibernate配置文件hibernate.cfg.xml的集成相当好，可以在Spring中配置Hibernate的SessionFactory从而取代Hibernate.cfg.xml和HibernateSessionFactory.javaSpring在集成Hibernate时又分为两种形式：（集成后就不需要Hibernate.cfg.xml了）使用Hibernate的映射文件*.hbm.xml时扫描映射文件的方法Spring集成Hibernate时去掉了Hibernate.cfg.xml，此时如果还继续使用Hibernate的映射文件_.hbm.xml的话，在配置Hibernate的 SessionFactory 时就要配置以何种方式寻找Hibernate映射文件_.hbm.xml此时spring中配置SessionFactory Bean时它对应的class应为org.springframework.orm.hibernate.LocalSessionFactoryBean例如：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://******:3306/database?useUnicode=true&amp;amp;characterEncoding=utf8"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;property name="maxActive" value="500"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="100"&gt;&lt;/property&gt; &lt;property name="maxWait" value="10000" /&gt; &lt;property name="removeAbandoned" value="true" /&gt; &lt;property name="removeAbandonedTimeout" value="60" /&gt; &lt;property name="logAbandoned" value="true" /&gt; &lt;property name="validationQuery" value="select 1" /&gt;&lt;/bean&gt;&lt;!-- 定义Hibernate的sessionFactory --&gt;&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;property name="dataSource"&gt; &lt;ref bean="dataSource" /&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!-- 数据库连接方言 --&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 在控制台输出SQL语句 --&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;!-- 格式化控制台输出的SQL语句 --&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.connection.release_mode"&gt;after_statement&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--Hibernate映射文件 --&gt; &lt;property name="mappingLocations"&gt; &lt;value&gt;/TBS/Model/*.hbm.xml&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- Action --&gt; &lt;bean id="LoginAction" class="PSM.Action.LoginAction"&gt; &lt;property name="loginDAO"&gt; &lt;ref local="LoginDAO"/&gt; &lt;/property&gt;&lt;/bean&gt;LocalSessionFactoryBean有好几个属性用来查找hibernate映射文件：mappingResources、mappingLocations、mappingDirectoryLocations与mappingJarLocations他们的区别：mappingResources：指定classpath下具体映射文件名123&lt;property name="mappingResources"&gt; &lt;value&gt;petclinic.hbm.xml &lt;/value&gt; &lt;/property&gt;mappingLocations：可以指定任何文件路径，并且可以指定前缀：classpath、file等123456&lt;property name="mappingLocations"&gt; &lt;value&gt;/WEB-INF/petclinic.hbm.xml &lt;/value&gt; &lt;/property&gt; &lt;property name="mappingLocations"&gt; &lt;value&gt;classpath:/com/company/domain/petclinic.hbm.xml &lt;/value&gt; &lt;/property&gt;也可以用通配符指定，’‘指定一个文件(路径)名，’*‘指定多个文件(路径)名，例如：123&lt;property name="mappingLocations"&gt; &lt;value&gt;classpath:/com/company/domainmaps/*.hbm.xml &lt;/value&gt; &lt;/property&gt;上面的配置是在com/company/domain包下任何maps路径下的hbm.xml文件都被加载为映射文件mappingDirectoryLocations：指定映射的文件路径12345&lt;property name="mappingDirectoryLocations"&gt; &lt;list&gt; &lt;value&gt;WEB-INF/HibernateMappings&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;也可以通过classpath来指出12345&lt;property name="mappingDirectoryLocations"&gt; &lt;list&gt; &lt;value&gt;classpath:/XXX/package/&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;mappingJarLocations：指定加载的映射文件在jar文件中使用jpa注解形式的pojo对象，而去掉*.hbm.xml的Hibernate映射文件 时配置的方法Spring集成Hibernate时去掉了Hibernate.cfg.xml，此时如果使用jpa注解形式的pojo对象，而去掉Hibernate的映射文件*.hbm.xml的话，在配置Hibernate的SessionFactory时就要配置以何种方式寻找jpa注解形式的pojo映射对象此时spring中配置SessionFactory bean时它对应的class应为org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean12345678910111213141516&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;!-- 引用数据源 --&gt; &lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.cn.nos.services.pojo*&lt;/value&gt;&lt;!-- 加载hibernate的jpa注解形式的实体类 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.SQLServerDialect&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;!--&lt;prop key="hibernate.current_session_context_class"&gt;thread&lt;/prop&gt;--&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;AnnotationSessionFactoryBean中查找jpa注解形式的pojo映射对象的属性有：annotatedClasses、packagesToScanannotatedClasses：指定classpath下指定的注解映射实体类的类名12345&lt;property name="annotatedClasses"&gt; &lt;list&gt; &lt;value&gt;com.test.ObjectBean&lt;/value&gt;&lt;!-- 可以在这个list中配置多个 --&gt; &lt;/list&gt;&lt;/property&gt;packagesToScan指定映射文件的包名12345&lt;property name=&quot;packagesToScan&quot;&gt; &lt;list&gt; &lt;value&gt;com.cn.nos.services.pojo*&lt;/value&gt;&lt;!-- 加载hibernate的jpa注解形式的实体类 --&gt; &lt;/list&gt;&lt;/property&gt;]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Spring</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2动态方法调用]]></title>
    <url>%2F2017%2F05%2F10%2Fa4d528a9-80ab-428f-a52c-e71eb2258026%2F</url>
    <content type="text"><![CDATA[Struts2动态方法调用在Struts2中方法调用概括起来主要有三种形式指定method属性123&lt;action name="student" class="com.itmyhome.Student" method="add"&gt; &lt;result name="add"&gt;/success.jsp&lt;/result&gt;&lt;/action&gt;这样Struts2就会调用Student 中的add方法。动态方法调用(DMI)用这种方法需要设置一个常量1&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt;动态方法调用是指表单元素的action并不是直接等于某个Action的名字，而是以如下形式来指定Form的action属性12&lt;!-- action属性为action!methodName的形式 --&gt;&lt;action = "action!methodName.action"在struts.xml中定义如下Action1234&lt;action name="student" class="com.itmyhome.StudentAction"&gt; &lt;result name="add"&gt;/add.jsp&lt;/result&gt; &lt;result name="delete"&gt;/delete.jsp&lt;/result&gt;&lt;/action&gt;StudentAction代码为12345678public class StudentAction extends ActionSupport &#123; public String add()&#123; return "add"; &#125; public String delete()&#123; return "delete"; &#125;&#125;则在JSP中用如下方式调用方法12&lt;a href=”http://student!add.action“&gt; 新增学生&lt;/a&gt;&lt;a href=“http://student!delete.action”&gt; 删除学生&lt;/a&gt;通配符（推荐使用）123&lt;action name="student*" class="com.itmyhome.StudentAction" method="&#123;1&#125;"&gt; &lt;result name="&#123;1&#125;"&gt;/student&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;则在JSP中用如下方式调用方法12&lt;a href=“http://studentadd”&gt; 新增学生&lt;/a&gt;&lt;a href=“http://studentdelete”&gt; 删除学生&lt;/a&gt;studentadd就会调用StudentAction中的add方法 然后跳转到studentadd.jspstudentdelete就会调用StudentAction中的delete方法 然后跳转到studentdelete.jspStruts2支持动态方法调用，它指的是一个Action中有多个方法， 系统根据表单元素给定的action来访问不同的方法，而不用写多个Action。]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列组合算法]]></title>
    <url>%2F2017%2F05%2F06%2Fb9a61a4d-b72d-4bdd-9343-017070461006%2F</url>
    <content type="text"><![CDATA[组合算法非递归算法组合算法的思路是开一个数组，其下标表示1到m个数，数组元素的值为1表示其下标代表的数被选中，为0则没选中。初始化，将数组前n个元素置1，表示第一个组合为前n个数。从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端。当第一个“1”移动到数组的m-n的位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。例如求5中选3的组合：123456789101 1 1 0 0 //1,2,3 1 1 0 1 0 //1,2,4 1 0 1 1 0 //1,3,4 0 1 1 1 0 //2,3,4 1 1 0 0 1 //1,2,5 1 0 1 0 1 //1,3,5 0 1 1 0 1 //2,3,5 1 0 0 1 1 //1,4,5 0 1 0 1 1 //2,4,5 0 0 1 1 1 //3,4,5c++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Combination &#123;public: void combination(int n, int m) &#123; int *a = new int[n]; for (int i = 0; i &lt; m; i++) a[i] = 1; for (int i = m; i &lt; n; i++) a[i] = 0; bool tag = true; while (tag) &#123; displayArray(a, n); for (int i = 0; i &lt; n - 1; i++) if (a[i] == 1 &amp;&amp; a[i + 1] == 0) &#123; tag = true; a[i] = 0; a[i + 1] = 1; moveZeros(a, i); break; &#125; else tag = false; &#125; &#125;private: void displayArray(int *a, int n) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; &#125; // 0到n-1，把1移到最左边 void moveZeros(int *a, int n) &#123; int left = 0, right = 0; while (right &lt; n) &#123; if (a[left] == 1) left++; else if (a[left] == 0 &amp;&amp; a[right] == 1) &#123; int t = a[left]; a[left] = a[right]; a[right] = t; left++; &#125; right++; &#125; &#125;&#125;;递归算法从n个数中选取编号最大的数，然后在剩下的n-1个数里面选取m-1个数，直到从n-(m-1)个数中选取1个数为止。从n个数中选取编号次小的一个数，继续执行1步，直到当前可选编号最大的数为m。c++代码如下:1234567891011121314151617181920212223242526class Combination &#123;public: void combination(int n, int m) &#123; int *a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = 0; func(a, n, m, n); &#125;private: void displayArray(int *a, int n) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; &#125; void func(int *a, int n, int m, const int N) &#123; if (m == 0) &#123; displayArray(a, N); return; &#125; for (int i = n - 1; i &gt;= m - 1; i--) &#123; a[i] = 1; func(a, i, m - 1, N); a[i] = 0; &#125; &#125;&#125;;排列算法递归算法如果集合是{a,b,c},那么这个集合中元素的所有排列是{(a,b,c),(a,c,b),(b,a,c),(b,c,a),(c,a,b),(c,b,a)}，显然，给定n个元素共有n!种不同的排列.如果给定集合是{a,b,c,d}，可以用下面给出的简单算法产生其所有排列，即集合(a,b,c,d)的所有排列有下面的排列组成：（1）以a开头后面跟着(b,c,d)的排列（2）以b开头后面跟着(a,c,d)的排列（3）以c开头后面跟着(a,b,d)的排列（4）以d开头后面跟着(a,b,c)的排列这显然是一种递归的思路，于是我们得到了以下的c++代码实现：12345678910111213141516171819202122232425262728class Permutation &#123;public: void permutation(int n) &#123; int *a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = 0; func(a, 1, n); &#125;private: void displayArray(int *a, int n) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; &#125; void func(int *a, int m, const int n) &#123; if (m == n + 1) &#123; displayArray(a, n); return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == 0) &#123; a[i] = m; func(a, m + 1, n); a[i] = 0; &#125; &#125; &#125;&#125;;非递归算法全排列生成算法的一个重要思路，就是将集合A中的元素的排列，与某种顺序建立一一映射的关系，按照这种顺序，将集合的所有排列全部输出。这种顺序需要保证，既可以输出全部的排列，又不能重复输出某种排列，或者循环输出一部分排列。字典序就是用此种思想输出全排列的一种方式。这里以A{1,2,3,4}来说明用字典序输出全排列的方法。首先，对于集合A的某种排列所形成的序列，字典序是比较序列大小的一种方式。以A{1,2,3,4}为例，其所形成的排列1234 &lt; 1243，比较的方法是从前到后依次比较两个序列的对应元素，如果当前位置对应元素相同，则继续比较下一个位置，直到第一个元素不同的位置为止，元素值大的元素在字典序中就大于元素值小的元素。上面的a1[1…4]=1234和a2[1…4]=1243，对于i=1,i=2，两序列的对应元素相等，但是当i=2时，有a1[2]=3 &lt; a2[2]=4，所以1234 &lt; 1243。使用字典序输出全排列的思路是，首先输出字典序最小的排列，然后输出字典序次小的排列，……，最后输出字典序最大的排列。这里就涉及到一个问题，对于一个已知排列，如何求出其字典序中的下一个排列。这里给出算法。对于排列a[1…n]，找到所有满足a[k] &lt; a[k+1] (0 &lt; k &lt; n-1)的k的最大值，如果这样的k不存在，则说明当前排列已经是a的所有排列中字典序最大者，所有排列输出完毕。在a[k+1…n]中，寻找满足这样条件的元素l，使得在所有a[l]&gt;a[k]的元素中，a[l]取得最小值。也就是说a[l]&gt;a[k]，但是小于所有其他大于a[k]的元素,交换a[l]与a[k].对于a[k+1…n]，反转该区间内元素的顺序。也就是说a[k+1]与a[n]交换，a[k+2]与a[n-1]交换，……，这样就得到了a[1…n]在字典序中的下一个排列。这里我们以排列a[1…8]=13876542为例，来解释一下上述算法。首先我们发现，1(38)76542，括号位置是第一处满足a[k] &lt; a[k+1]的位置，此时k=2。所以我们在a[3…8]的区间内寻找比a[2]=3大的最小元素，找到a[7]=4满足条件，交换a[2]和a[7]得到新排列14876532，对于此排列的3～8区间，反转该区间的元素，将a[3]-a[8]，a[4]-a[7]，a[5]-a[6]分别交换，就得到了13876542字典序的下一个元素14235678。下面是该算法的实现代码：12345678910111213141516171819202122232425262728293031323334353637class Permutation &#123;public: void permutation(int n) &#123; int *a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = i + 1; while (true) &#123; displayArray(a, n); //找到k int k = n - 2; while (k != -1 &amp;&amp; a[k] &gt; a[k + 1]) k--; if (k == -1) return; // 交换比k稍大的数 int l = k + 1; for (int i = k + 1; i &lt; n; i++) if (a[i] &gt; a[k] &amp;&amp; a[i] &lt; a[l]) l = i; int t = a[k]; a[k] = a[l]; a[l] = t; //反转 for (int i = 1; 2 * i &lt; n - k; i++) &#123; int t = a[k + i]; a[k + i] = a[n - i]; a[n - i] = t; &#125; &#125; &#125;private: void displayArray(int *a, int n) &#123; for (int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git命令简介]]></title>
    <url>%2F2017%2F05%2F05%2F4b10e722-0699-4590-90d3-0e7e12358518%2F</url>
    <content type="text"><![CDATA[创建版本库通过git init命令把这个目录变成Git可以管理的仓库把文件添加到版本库git add把文件提交到仓库git add .则是将该目录下的所有的文件或文件夹递归地提交到仓库git status命令可以让我们时刻掌握仓库当前的状态git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式git commit提交修改到版本库git log查看提交的历史记录##分支管理git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch dev创建分支git checkout dev切换分支git branch命令查看当前分支,该命令会列出所有分支，当前分支前面会标一个*号。远程仓库（GitHub）创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：1$ ssh-keygen -t rsa -C "youremail@example.com"你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。在GitHub中添加SSH Key登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容点“Add Key”，你就应该看到已经添加的Key。远程仓库的推送和抓取git remote add origin git@github.com:alanice/learngit.git添加远程仓库git push -u origin master第一次推送master分支的所有内容git push origin master把本地master分支的最新修改推送至GitHubgit clone克隆一个本地库git pull和git fetch的区别git fetch相当于是从远程获取最新版本到本地，不会自动merge123git fetch origin mastergit log -p master..origin/mastergit merge origin/master以上命令的含义：首先从远程的origin的master主分支下载最新的版本到origin/master分支上然后比较本地的master分支和origin/master分支的差别,最后进行合并上述过程其实可以用以下更清晰的方式来进行：123git fetch origin master:tmpgit diff tmp git merge tmp从远程获取最新的版本到本地的tmp分支上,之后再进行比较合并git pull相当于是从远程获取最新版本并merge到本地1git pull origin master上述命令其实相当于git fetch和git merge在实际使用中，git fetch更安全一些,因为在merge前，我们可以查看更新情况，然后再决定是否合并新建、删除远程分支git push origin &lt;branch-name&gt;可以把本地分支推送到远程分支git push --delete origin &lt;branch-name&gt;可以删除指定的远程分支bug分支git stash可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作git stash list命令看看刚才的工作现场git stash apply恢复工作现场，但是恢复后stash内容并不删除，需要用git stash drop来删除git stash pop恢复的同时把stash内容也删了只提交一次的文件git update-index --assume-unchanged FILENAME忽略已经提交的文件git update-index --no-assume-unchanged FILENAME重新track相关文件删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支：1git push origin --delete &lt;branchname&gt;可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支：1git push origin :&lt;branchname&gt;删除tag的方法，推送一个空tag到远程tag,两种语法作用完全相同。：123git push origin --delete tag &lt;tagname&gt;git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt;删除不存在对应远程分支的本地分支使用git remote prune origin可以将其从本地版本库中去除。更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支git fetch -p重命名远程分支在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。例如下面的例子中，我需要把devel分支重命名为develop分支：删除远程分支：git push --delete origin devel重命名本地分支：git branch -m devel develop推送本地分支：git push origin develop把本地tag推送到远程1git push --tags获取远程tag1git fetch origin tag &lt;tagname&gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式简介]]></title>
    <url>%2F2017%2F05%2F03%2Fa6de9982-f81f-401a-a8b2-e69e3689d933%2F</url>
    <content type="text"><![CDATA[设计模式的分类总体来说设计模式分为三大类：创建型模式创建型模式共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式结构型模式共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式行为型模式共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。设计模式的六大原则总原则：开闭原则 (Open Close Principle)定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面6大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。说到这里，再回想一下前面说的6项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。单一职责原则 (Single responsibility principle)定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）举例说明，用一个类描述动物呼吸这个场景：12345678910111213class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+"呼吸空气"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe("牛"); animal.breathe("羊"); animal.breathe("猪"); &#125;&#125;运行结果：123牛呼吸空气羊呼吸空气猪呼吸空气程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：123456789101112131415161718192021class Terrestrial&#123; public void breathe(String animal)&#123; System.out.println(animal+"呼吸空气"); &#125;&#125;class Aquatic&#123; public void breathe(String animal)&#123; System.out.println(animal+"呼吸水"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Terrestrial terrestrial = new Terrestrial(); terrestrial.breathe("牛"); terrestrial.breathe("羊"); terrestrial.breathe("猪"); Aquatic aquatic = new Aquatic(); aquatic.breathe("鱼"); &#125;&#125;运行结果：1234牛呼吸空气羊呼吸空气猪呼吸空气鱼呼吸水我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：123456789101112131415161718class Animal&#123; public void breathe(String animal)&#123; if("鱼".equals(animal))&#123; System.out.println(animal+"呼吸水"); &#125;else&#123; System.out.println(animal+"呼吸空气"); &#125; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe("牛"); animal.breathe("羊"); animal.breathe("猪"); animal.breathe("鱼"); &#125;&#125;可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：1234567891011121314151617class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+"呼吸空气"); &#125; public void breathe2(String animal)&#123; System.out.println(animal+"呼吸水"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe("牛"); animal.breathe("羊"); animal.breathe("猪"); animal.breathe2("鱼"); &#125;&#125;可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。遵循单一职责原的优点有：可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响；需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。里氏替换原则 (Liskov Substitution Principle)定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。所有引用基类的地方必须能透明地使用其子类的对象。问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。123456789101112class A&#123; public int func1(int a, int b)&#123; return a-b; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); System.out.println("100-50="+a.func1(100, 50)); System.out.println("100-80="+a.func1(100, 80)); &#125;&#125;运行结果：12100-50=50100-80=20后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：两数相减。两数相加，然后再加100。由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：1234567891011121314151617class B extends A &#123; public int func1(int a, int b)&#123; return a+b; &#125; public int func2(int a, int b)&#123; return func1(a,b)+100; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; B b = new B(); System.out.println("100-50="+b.func1(100, 50)); System.out.println("100-80="+b.func1(100, 80)); System.out.println("100+20+100="+b.func2(100, 20)); &#125;&#125;类B完成后，运行结果：123100-50=150100-80=180100+20+100=220我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 2. 子类中可以增加自己特有的方法。 3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？后果就是：你写的代码出问题的几率将会大大增加。依赖倒转原则 (Dependence Inversion Principle)定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：1234567891011121314151617class Book&#123; public String getContent()&#123; return "很久很久以前有一个阿拉伯的故事……"; &#125;&#125;class Mother&#123; public void narrate(Book book)&#123; System.out.println("妈妈开始讲故事"); System.out.println(book.getContent()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); &#125;&#125;运行结果：12妈妈开始讲故事很久很久以前有一个阿拉伯的故事……运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：12345class Newspaper&#123; public String getContent()&#123; return "林书豪38+7领导尼克斯击败湖人……"; &#125;&#125;这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：123interface IReader&#123; public String getContent();&#125;Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：1234567891011121314151617181920212223class Newspaper implements IReader &#123; public String getContent()&#123; return "林书豪17+9助尼克斯击败老鹰……"; &#125;&#125;class Book implements IReader&#123; public String getContent()&#123; return "很久很久以前有一个阿拉伯的故事……"; &#125;&#125;class Mother&#123; public void narrate(IReader reader)&#123; System.out.println("妈妈开始讲故事"); System.out.println(reader.getContent()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); mother.narrate(new Newspaper()); &#125;&#125;运行结果：1234妈妈开始讲故事很久很久以前有一个阿拉伯的故事……妈妈开始讲故事林书豪17+9助尼克斯击败老鹰……这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。在实际编程中，我们一般需要做到如下3点：1. 低层模块尽量都要有抽象类或接口，或者两者都有。 2. 变量的声明类型尽量是抽象类或接口。 3. 使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。接口隔离原则 (Interface Segregation Principle)定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。举例来说明接口隔离原则：这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。采用接口隔离原则对接口进行约束时，要注意以下几点：1. 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 2. 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 3. 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。迪米特法则 (Demeter Principle)定义：一个对象应该对其他对象保持最少的了解（最少知道原则）。问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。解决方案：尽量降低类与类之间的耦合。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//总公司员工class Employee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;//分公司员工class SubEmployee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId("分公司"+i); list.add(emp); &#125; return list; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId("总公司"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1)&#123; System.out.println(e.getId()); &#125; List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); &#125;&#125;现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:1234567891011121314151617181920212223242526272829303132333435363738class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId("分公司"+i); list.add(emp); &#125; return list; &#125; public void printEmployee()&#123; List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list)&#123; System.out.println(e.getId()); &#125; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId("总公司"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125;修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。合成复用原则 (Composite Reuse Principle)定义：尽量使用对象组合，而不是继承来达到复用的目的。问题由来：在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。解决方案：在实现复用时应该多用关联，少用继承。]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA下SSH集成JUnit4进行测试]]></title>
    <url>%2F2017%2F05%2F02%2F5bcd744d-4cbe-44d7-a84c-2418956fdaa4%2F</url>
    <content type="text"><![CDATA[导入相应的jar包junit4 整个套装，包括junit4.jar和hamcrest-core.jarstruts2 需要导入的是 struts2-junit-plugin.jarspring 需要导入的是 spring-test.jar新建测试文件夹在项目根目录下新建test文件夹，以后编写的测试类应该和被测试类保持包名一致，并把一些spring的配置文件（例如applicationContext.xml文件）放到test目录下编写测试类在测试类的头部写下如下注解12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath*:applicationContext.xml")并在测试类里添加待测试的对象12@Resource(name="defaultService")private defaultService defaultService;编写测试方法123456789101112/** * Method: updateArticleWithoutContent(String uuid, String title, String categories, String tags) */@Testpublic void testUpdateArticleWithoutContent() throws Exception &#123; String uuid = ""; String title = ""; String categories = ""; String tags = ""; String json = defaultService.updateArticleWithoutContent(uuid, title, categories, tags); System.out.println(json);&#125;测试结果如图测试成功]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>JUnit4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH框架搭建]]></title>
    <url>%2F2017%2F05%2F02%2Fc08c489f-2019-41b6-a83f-fd7c8b025509%2F</url>
    <content type="text"><![CDATA[导入相应的jar包struts2目前struts2已经升级到2.5.12（2017-07-22），x-work已经被合并到struts2-core里面去了。同时还需要添加log4j-api相关jar包spring4hibernate5mysql配置XML我的目录分布：web.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;TBS&lt;/display-name&gt; &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;struts-default.xml,struts-plugin.xml,../conf/struts.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/conf/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;struts.xml123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;default-action-ref name="APIDoc" /&gt; &lt;action name="APIDoc" class="APIAction"&gt; &lt;result name="success"&gt;/APIDoc.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;!-- package 可以继承 --&gt; &lt;package name="movie" namespace="/movie" extends="default"&gt; &lt;action name="*" class="APIAction" method="getMovie" /&gt; &lt;/package&gt;&lt;/struts&gt;applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd "&gt; &lt;context:property-placeholder ignore-unresolvable="true" location="classpath:../conf/jdbc.properties" /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.logicalcobwebs.proxool.ProxoolDataSource"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="driverUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="alias" value="proxoolPool" /&gt; &lt;property name="houseKeepingSleepTime" value="90000" /&gt; &lt;property name="prototypeCount" value="5" /&gt; &lt;property name="maximumConnectionCount" value="50" /&gt; &lt;property name="minimumConnectionCount" value="2" /&gt; &lt;property name="simultaneousBuildThrottle" value="50" /&gt; &lt;property name="maximumConnectionLifetime" value="14400000" /&gt; &lt;property name="houseKeepingTestSql" value="select CURRENT_DATE" /&gt; &lt;/bean&gt; &lt;!-- 定义Hibernate的sessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;!-- 数据库连接方言 --&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;!-- 在控制台输出SQL语句 --&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;!-- 格式化控制台输出的SQL语句 --&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.connection.release_mode"&gt;after_statement&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="mappingLocations"&gt; &lt;value&gt;classpath:/priv/dbs/model/*.hbm.xml&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义事务管理器（声明式的事务） --&gt; &lt;bean id="transactionManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 定义事务 --&gt; &lt;bean id="transactionInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;property name="transactionAttributes"&gt; &lt;props&gt; &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;prop key="save*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;prop key="add*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;prop key="edit*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;prop key="delete*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- aop管理事务 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt; &lt;property name="beanNames"&gt; &lt;value&gt;*Dao&lt;/value&gt; &lt;/property&gt; &lt;property name="interceptorNames"&gt; &lt;value&gt;transactionInterceptor&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Action --&gt; &lt;bean id="APIAction" class="priv.dbs.action.APIAction"&gt; &lt;property name="apiService" ref="APIService" /&gt; &lt;/bean&gt; &lt;!-- Service --&gt; &lt;bean id="APIService" class="priv.dbs.service.APIService"&gt; &lt;property name="apiDao" ref="APIDao" /&gt; &lt;/bean&gt; &lt;!-- Dao --&gt; &lt;bean id="APIDao" class="priv.dbs.dao.APIDao"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt;&lt;/beans&gt;jdbc.properties123jdbc.url=jdbc:mysql\:///db?useUnicode\=true&amp;characterEncoding\=UTF-8&amp;useSSL\=falsejdbc.user=userjdbc.password=password]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSON使用介绍]]></title>
    <url>%2F2017%2F05%2F02%2Fbb662958-398d-4d53-b7c6-9738832b0781%2F</url>
    <content type="text"><![CDATA[Gson介绍Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。而JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。下载地址：Gson对象转JSON单独转一个对象123Article item;Gson gson = new Gson();String result = gson.toJson(item);输出结果：1&#123;&quot;id&quot;:1,&quot;uuid&quot;:&quot;868621d3-d55d-486e-bd7e-1f2df5ec4746&quot;,&quot;title&quot;:&quot;Update Test Title&quot;,&quot;categories&quot;:&quot;Update Test Categories&quot;,&quot;tags&quot;:&quot;Update Test Tags&quot;,&quot;createTime&quot;:&quot;May 23, 2017 11:38:38 PM&quot;,&quot;updateTime&quot;:&quot;May 24, 2017 9:46:46 PM&quot;,&quot;enable&quot;:true&#125;转一组对象123List&lt;Article&gt; items;Gson gson = new Gson();String result = gson.toJson(items);输出结果：1&#123;&quot;[&#123;&quot;id&quot;:1,&quot;uuid&quot;:&quot;868621d3-d55d-486e-bd7e-1f2df5ec4746&quot;,&quot;title&quot;:&quot;Update Test Title&quot;,&quot;categories&quot;:&quot;Update Test Categories&quot;,&quot;tags&quot;:&quot;Update Test Tags&quot;,&quot;createTime&quot;:&quot;May 23, 2017 11:38:38 PM&quot;,&quot;updateTime&quot;:&quot;May 24, 2017 9:46:46 PM&quot;,&quot;enable&quot;:true&#125;,&#123;&quot;id&quot;:2,&quot;uuid&quot;:&quot;e58d3d06-8a40-4d64-9329-7a4be87ba1dc&quot;,&quot;title&quot;:&quot;Test Title&quot;,&quot;categories&quot;:&quot;Test Categories&quot;,&quot;tags&quot;:&quot;Test Tags&quot;,&quot;createTime&quot;:&quot;May 23, 2017 11:44:41 AM&quot;,&quot;updateTime&quot;:&quot;May 23, 2017 11:44:41 AM&quot;,&quot;enable&quot;:true&#125;,&#123;&quot;id&quot;:3,&quot;uuid&quot;:&quot;bb662958-398d-4d53-b7c6-9738832b0781&quot;,&quot;title&quot;:&quot;Test Title&quot;,&quot;categories&quot;:&quot;Test Categories&quot;,&quot;tags&quot;:&quot;Test Tags&quot;,&quot;createTime&quot;:&quot;May 23, 2017 8:42:01 PM&quot;,&quot;updateTime&quot;:&quot;May 23, 2017 8:42:01 PM&quot;,&quot;enable&quot;:true&#125;]设置日期时间格式12345List&lt;Article&gt; items;GsonBuilder gsonBuilder = new GsonBuilder();gsonBuilder.setDateFormat("yyyy-MM-dd HH:mm:ss");Gson gson = gsonBuilder.create();String result = gson.toJson(items);输出结果：1[&#123;&quot;id&quot;:1,&quot;uuid&quot;:&quot;868621d3-d55d-486e-bd7e-1f2df5ec4746&quot;,&quot;title&quot;:&quot;Update Test Title&quot;,&quot;categories&quot;:&quot;Update Test Categories&quot;,&quot;tags&quot;:&quot;Update Test Tags&quot;,&quot;createTime&quot;:&quot;2017-05-23 23-38-38&quot;,&quot;updateTime&quot;:&quot;2017-05-24 21-46-46&quot;,&quot;enable&quot;:true&#125;,&#123;&quot;id&quot;:2,&quot;uuid&quot;:&quot;e58d3d06-8a40-4d64-9329-7a4be87ba1dc&quot;,&quot;title&quot;:&quot;Test Title&quot;,&quot;categories&quot;:&quot;Test Categories&quot;,&quot;tags&quot;:&quot;Test Tags&quot;,&quot;createTime&quot;:&quot;2017-05-23 11-44-41&quot;,&quot;updateTime&quot;:&quot;2017-05-23 11-44-41&quot;,&quot;enable&quot;:true&#125;,&#123;&quot;id&quot;:3,&quot;uuid&quot;:&quot;bb662958-398d-4d53-b7c6-9738832b0781&quot;,&quot;title&quot;:&quot;Test Title&quot;,&quot;categories&quot;:&quot;Test Categories&quot;,&quot;tags&quot;:&quot;Test Tags&quot;,&quot;createTime&quot;:&quot;2017-05-23 20-42-01&quot;,&quot;updateTime&quot;:&quot;2017-05-23 20-42-01&quot;,&quot;enable&quot;:true&#125;]隐藏某些域12345678910111213141516171819List&lt;Article&gt; items;GsonBuilder gsonBuilder = new GsonBuilder();gsonBuilder.setExclusionStrategies(new ExclusionStrategy() &#123; @Override public boolean shouldSkipField(FieldAttributes fieldAttributes) &#123; String[] skipFields = &#123;"enable"&#125;; String field = fieldAttributes.getName().toLowerCase(); for (String skipField : skipFields) if (field.equals(skipField)) return true; return false; &#125; @Override public boolean shouldSkipClass(Class&lt;?&gt; aClass) &#123; return false; &#125;&#125;);Gson gson = gsonBuilder.create();String result = gson.toJson(items);输出结果：1[&#123;&quot;id&quot;:1,&quot;uuid&quot;:&quot;868621d3-d55d-486e-bd7e-1f2df5ec4746&quot;,&quot;title&quot;:&quot;Update Test Title&quot;,&quot;categories&quot;:&quot;Update Test Categories&quot;,&quot;tags&quot;:&quot;Update Test Tags&quot;,&quot;createTime&quot;:&quot;2017-05-23 23:38:38&quot;,&quot;updateTime&quot;:&quot;2017-05-24 21:46:46&quot;&#125;,&#123;&quot;id&quot;:2,&quot;uuid&quot;:&quot;e58d3d06-8a40-4d64-9329-7a4be87ba1dc&quot;,&quot;title&quot;:&quot;Test Title&quot;,&quot;categories&quot;:&quot;Test Categories&quot;,&quot;tags&quot;:&quot;Test Tags&quot;,&quot;createTime&quot;:&quot;2017-05-23 11:44:41&quot;,&quot;updateTime&quot;:&quot;2017-05-23 11:44:41&quot;&#125;,&#123;&quot;id&quot;:3,&quot;uuid&quot;:&quot;bb662958-398d-4d53-b7c6-9738832b0781&quot;,&quot;title&quot;:&quot;Test Title&quot;,&quot;categories&quot;:&quot;Test Categories&quot;,&quot;tags&quot;:&quot;Test Tags&quot;,&quot;createTime&quot;:&quot;2017-05-23 20:42:01&quot;,&quot;updateTime&quot;:&quot;2017-05-23 20:42:01&quot;&#125;]JSON转对象首先建立JSON对应的对象12345class JsonHolder &#123; public boolean success; public String uuid; public String message;&#125;转单个对象编写测试代码12345678910@Testpublic void testJsonObeject() &#123; String uuid = "4b10e722-0699-4590-90d3-0e7e12358518"; String json = "&#123;\"success\":true, \"uuid\":\"" + uuid + "\"&#125;"; json = "&#123;\"success\":false, \"message\":\"can't create new file!\"&#125;"; JsonHolder item = new Gson().fromJson(json, JsonHolder.class); System.out.println(item.success); System.out.println(item.uuid); System.out.println(item.message);&#125;输出结果123falsenullcan&apos;t create new file!转一组对象编写测试代码123456789101112@Testpublic void testJsonObeject() &#123; String uuid = &quot;4b10e722-0699-4590-90d3-0e7e12358518&quot;; String json = &quot;&#123;\&quot;success\&quot;:true, \&quot;uuid\&quot;:\&quot;&quot; + uuid + &quot;\&quot;&#125;&quot;; String longJson = &quot;[&quot; + json + &quot;,&quot; + json + &quot;,&quot; + json + &quot;]&quot;; JsonHolder[] items = new Gson().fromJson(longJson, JsonHolder[].class); for (JsonHolder item : items) &#123; System.out.println(item.success); System.out.println(item.uuid); System.out.println(item.message); &#125;&#125;转复杂对象先给出一个比较复杂的JSON12345678910111213141516171819202122232425262728&#123; &quot;error&quot;: 0, &quot;status&quot;: &quot;success&quot;, &quot;date&quot;: &quot;2014-05-10&quot;, &quot;results&quot;: [ &#123; &quot;currentCity&quot;: &quot;南京&quot;, &quot;weather_data&quot;: [ &#123; &quot;date&quot;: &quot;周六(今天, 实时：19℃)&quot;, &quot;dayPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/day/dayu.png&quot;, &quot;nightPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/night/dayu.png&quot;, &quot;weather&quot;: &quot;大雨&quot;, &quot;wind&quot;: &quot;东南风5-6级&quot;, &quot;temperature&quot;: &quot;18℃&quot; &#125;, &#123; &quot;date&quot;: &quot;周日&quot;, &quot;dayPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/day/zhenyu.png&quot;, &quot;nightPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/night/duoyun.png&quot;, &quot;weather&quot;: &quot;阵雨转多云&quot;, &quot;wind&quot;: &quot;西北风4-5级&quot;, &quot;temperature&quot;: &quot;21 ~ 14℃&quot; &#125; ] &#125; ]&#125;构造接收这个JSON的对象：123456789101112131415161718class JsonHolder &#123; public int error; public String status; public String date; public A[] results; class A &#123; public String currentCity; public B[] weather_data; class B &#123; public String date; public String dayPictureUrl; public String nightPictureUrl; public String weather; public String wind; public String temperature; &#125; &#125;&#125;编写测试代码123456789101112131415@Testpublic void testJsonObeject() throws IOException &#123; String json = ""; BufferedReader br = new BufferedReader(new FileReader("/home/alan/Documents/WorkSpace/Intellij_IDEA_workspace/MyBlog/test/json.txt")); String line = ""; while ((line = br.readLine()) != null) &#123; json += line; &#125; br.close(); JsonHolder jsonHolder = new Gson().fromJson(json, JsonHolder.class); System.out.println(jsonHolder.status); System.out.println(jsonHolder.results[0].currentCity); System.out.println(jsonHolder.results[0].weather_data[1].weather); System.out.println(jsonHolder.results[0].weather_data[1].temperature);&#125;输出结果：1234success南京阵雨转多云21 ~ 14℃]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建过程(二)]]></title>
    <url>%2F2017%2F05%2F01%2Fe58d3d06-8a40-4d64-9329-7a4be87ba1dc%2F</url>
    <content type="text"><![CDATA[开启字数统计hexo-wordcount hexo-wordcount安装hexo-wordcount插件1npm install hexo-wordcount --save修改主题配置文件1234post_wordcount: item_text: true wordcount: true min2read: true修改yoursite/themes/next/layout/_macro/post.swig文件(重点在13行和30行)12345678910111213141516171819202122232425262728293031&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125; &lt;div class="post-wordcount"&gt; &#123;% if theme.post_wordcount.wordcount %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.wordcount') &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;字&lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.wordcount and theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-clock-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read') &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt; &lt;span class="post-meta-item-text"&gt;分钟&lt;/span&gt; &#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125;文章末尾统一添加“本文结束”标记新建article-end-tag.swig文件在路径yoursite/themes/next/layout/_macro中添加article-end-tag.swig文件，其内容为：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;blockquote class="blockquote-center"&gt;本文完，如果您觉得本博客对您有帮助，请持续关注，谢谢！&lt;/blockquote&gt; &#123;% endif %&#125;&lt;/div&gt;修改post.swig文件在yoursite/themes/next/layout/_macro/post.swig中，在post-body之后添加如下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'article-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;在主题配置文件中添加字段在主题配置文件中添加以下字段开启此功能：12article_end_tag: enable: true完成以上设置之后，在每篇文章之后都会添加“本文结束”标记。设置点击出现心心效果love.js把js文件love.js放在yoursite/themes/next/source/js/src下，更新yoursite/themes/next/layout/_layout.swig文件，在末尾添加以下代码(如果存在就不必添加了)：1&#123;% include '_custom/special_effects.swig' %&#125;在yoursite/themes/next/layout/_custom/special_effects.swig里添加如下代码：123&#123;% if theme.special_effects.love %&#125; &lt;script type="text/javascript" src="/js/src/love.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125;最后在主题配置文件任意位置添加如下代码即可：12special_effects: love: true添加背景音乐(方法1,已经弃用)在yoursite/themes/next/source/js/src下新建backgroundmusic.js文件，内容如下：123456789101112$(function() &#123; var player = $('#background-audio')[0]; $('.site-nav .menu .menu-item.menu-item-backgroundmusic a').click(function() &#123; if (player.paused) &#123; player.play(); $(this).html('&lt;i class="menu-item-icon fa fa-fw fa-pause"&gt;&lt;/i&gt;&lt;br&gt;暂停'); &#125; else &#123; player.pause(); $(this).html('&lt;i class="menu-item-icon fa fa-fw fa-play-circle"&gt;&lt;/i&gt;&lt;br&gt;播放'); &#125; &#125;);&#125;)更新yoursite/themes/next/layout/_layout.swig文件，在末尾添加以下代码(如果存在就不必添加了)：1&#123;% include '_custom/special_effects.swig' %&#125;在yoursite/themes/next/layout/_custom/special_effects.swig里添加如下代码：12345678&#123;% if theme.menu.backgroundmusic %&#125; &lt;script type="text/javascript" src="/js/src/backgroundmusic.js"&gt;&lt;/script&gt; &lt;audio id="background-audio" hidden="hidden" loop="loop"&gt; &#123;% for music_url in theme.special_effects.backgroundmusic %&#125; &lt;source src="&#123;&#123; music_url &#125;&#125;" type="audio/mpeg"&gt; &#123;% endfor %&#125; &lt;/audio&gt;&#123;% endif %&#125;修改主题配置文件(部分其他内容省略)1234menu: backgroundmusic: javascript:;menu_icons: backgroundmusic: play-circle最后在主题配置文件任意位置添加如下代码即可：1234special_effects: backgroundmusic: - mp3地址1(本地和互联网资源都行) - mp3地址2(本地和互联网资源都行)添加背景音乐(方法2,有点复杂)首先先给出依赖吧，这里主要用到了两个模块:artDialog 用来进行弹出窗口Amazing Audio Player 音乐播放器在yoursite/themes/next/layout/_custom/special_effects.swig里添加如下代码：123456789101112131415161718192021222324252627&#123;% if theme.menu.backgroundmusic %&#125; &lt;script type="text/javascript"&gt; var playerHtml = '\ &lt;div class="demo-slider" id="player"&gt;\ &lt;link rel="stylesheet" type="text/css" media="all" href="/js/src/player/initaudioplayer.css"&gt;\ &lt;div id="amazingaudioplayer-8" style="display:block;position:relative;width:320px;height:auto;margin:0px auto 0px;"&gt;\ &lt;ul class="amazingaudioplayer-audios" style="display:none;"&gt;\ ' &#123;% for item in theme.special_effects.backgroundmusic %&#125; playerHtml += '\ &lt;li data-title="&#123;&#123; item.title &#125;&#125;" data-image="&#123;&#123; item.image &#125;&#125;"&gt;\ &lt;div class="amazingaudioplayer-source" data-src="&#123;&#123; item.src &#125;&#125;" data-type="audio/mpeg"&gt;&lt;/div&gt;\ &lt;/li&gt;\ ' &#123;% endfor %&#125; playerHtml += '\ &lt;/ul&gt;\ &lt;/div&gt;\ &lt;/div&gt;\ ' &lt;/script&gt; &lt;script type="text/javascript" src="/js/src/player/dialog-plus.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/player/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/player/amazingaudioplayer.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/player/initplayer.js"&gt;&lt;/script&gt;&#123;% endif %&#125;最后在主题配置文件任意位置添加如下代码即可：(其中title是音乐名称，image是音乐海报地址，src是音乐地址)1234567891011special_effects: backgroundmusic: - title: 华胥一梦 image: /js/src/player/music/华胥一梦.jpg src: /js/src/player/music/阿鲲-华胥一梦.mp3 - title: 天下第一 image: /js/src/player/music/天下第一.jpg src: /js/src/player/music/麦振鸿,罗坚 - 天下第一.mp3 - title: 雪见—仙凡之旅 image: /js/src/player/music/雪见—仙凡之旅.png src: /js/src/player/music/麦振鸿 - 雪见—仙凡之旅.mp3大家可以研究下initplayer.js文件，详细的实现过程就不叙述了。播放器通过上面的音乐图标可以唤出。开启代码隐藏功能在yoursite/themes/next/source/js/src下新建collapse-code.js文件，内容如下：1234567891011121314151617181920212223242526272829$(function() &#123; var index = 0; $('figure').each(function() &#123; var children = $(this).find('table tbody tr td.code div'); if (children.length &gt; line_limit) &#123; index++; var collapse_item = $('&lt;h6&gt;&lt;i class="fa fa-chevron-up"&gt;&lt;/i&gt;&lt;span class="collapse-label"&gt;收起&lt;/span&gt;&lt;/h6&gt;'); $(this).prepend(collapse_item); var table = $(this).find('table'); var div = $('&lt;div&gt;&lt;/div&gt;'); table.remove(); div.append(table); $(this).append(div); $(this).find('h6').click(function() &#123; if (div.is(':hidden')) &#123; collapse_item.find('i').removeClass('close'); collapse_item.find('span.collapse-label').html('收起'); &#125; else &#123; collapse_item.find('i').addClass('close'); collapse_item.find('span.collapse-label').html('展开'); &#125; var slide_time = children.length * 20; if (slide_time &lt; 200) slide_time = 200; else if (slide_time &gt; 2000) slide_time = 2000; div.slideToggle(); &#125;); &#125; &#125;);&#125;)更新yoursite/themes/next/layout/_layout.swig文件，在末尾添加以下代码(如果存在就不必添加了)：1&#123;% include '_custom/special_effects.swig' %&#125;在yoursite/themes/next/layout/_custom/special_effects.swig里添加如下代码：1234&#123;% if theme.special_effects.collapse_code !== undefined %&#125; &lt;script type="text/javascript"&gt;var line_limit = &#123;&#123; theme.special_effects.collapse_code &#125;&#125;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/collapse-code.js"&gt;&lt;/script&gt;&#123;% endif %&#125;接下来还需要修改yoursite/themes/next/source/css/_custom/custom.styl文件1234567891011121314figure&gt;h6 &#123; margin: 0; padding: 8px!important; cursor: pointer;&#125;figure&gt;h6&gt;i &#123; margin-left: 30px; margin-right: 10px; transition: all 0.4s ease;&#125;figure&gt;h6&gt;i.close &#123; transform: rotate(180deg); color: #b63b4d;&#125;修改主题配置文件，在任意位置下添加下列代码，数字表示超过多少行开启折叠功能。12special_effects: collapse_code: 10]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建过程(一)]]></title>
    <url>%2F2017%2F05%2F01%2F868621d3-d55d-486e-bd7e-1f2df5ec4746%2F</url>
    <content type="text"><![CDATA[本文旨在介绍Hexo的简单美化和自定义定制，博客搭建教程可以另行查阅Hexo官方文档，另外也有网上很多教程。同时，接触一个新的技术要多看看文档，文档可以帮助你很快熟悉整个项目。NodejsDownload | Node.jsHexoHexoNexT主题NexT 使用文档为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。为文章设置头部背景图片和边框编辑yoursite/themes/next/source/css/_custom/custom.styl文件，加入如下代码123456789101112.header &#123; background-image: url("../images/header.jpg"); background-position: center center; background-size: cover;&#125;.posts-expand .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(200,210,220,.75); -moz-box-shadow: 0 0 5px rgba(200,210,220,.75)&#125;增加文章的宽度编辑yoursite/themes/next/source/css/_variables/custom.styl文件，加入如下代码：1234// 修改成你期望的宽度$content-desktop = 800px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1000px为博客添加背景图片编辑yoursite/themes/next/source/css/_custom/custom.styl文件，加入如下代码：12345678910111213#main &#123; background-image: url("../images/background.png"); background-position: center center; background-repeat:no-repeat; background-attachment: fixed; background-size: cover;&#125;.footer-inner &#123; background: rgba(255,255,255,.75);&#125;.posts-expand .post &#123; background: rgb(224,224,224);&#125;由于手机端的浏览器不支持background-attachment: fixed;属性，所以我们需要在移动端把背景换一下。123456789@media screen and (max-width: 400px) &#123; #main &#123; background-image: url("../images/background_mobile.jpg"); background-position: auto; background-repeat: repeat; background-size: auto; background-attachment: scroll; &#125;&#125;美化链接样式正如本文开头的几个链接，样式要好看一些，下面是美化的步骤：编辑yoursite/themes/next/source/css/_custom/custom.styl文件，加入如下代码即可：1234567891011121314151617181920a[href][target="_blank"][rel="external"] &#123; padding: 0 20px; border: 2px solid #555; text-decoration: none; display: inline-block; overflow: hidden; color: #555; font-size: 14px; background: #fff; border-radius: 2px; transition: all 0.3s ease;&#125;a[href][target="_blank"][rel="external"]:hover &#123; color: white; background-color: black; border-color: black;&#125;a[href][target="_blank"][rel="external"] i &#123; margin-right: 5px;&#125;压缩代码Next主题在Hexo引擎解析md时生成的代码会包含大量的无用空白，所以我们使用Hexo-neat插件对其进行优化。Hexo-neat首先安装Hexo-neat插件1npm install hexo-neat --save然后在站点配置文件里加入1npm install hexo-neat --save美化内容文章可以通过增加CSS，并在文章内容里增加html标签可以使文章更美观，例如：有颜色的块redblueyellowgreenpurple实现代码：12345&lt;span class="inline-span red"&gt;red&lt;/span&gt;&lt;span class="inline-span blue"&gt;blue&lt;/span&gt;&lt;span class="inline-span yellow"&gt;yellow&lt;/span&gt;&lt;span class="inline-span green"&gt;green&lt;/span&gt;&lt;span class="inline-span purple"&gt;purple&lt;/span&gt;有颜色的文本段落这是边框带颜色的文本段落位置可选: left | right | top颜色可选: red | blue | yellow | green | purple实现代码：12345&lt;div class="div-border left-red"&gt;这是边框带颜色的文本段落位置可选: left | right | top颜色可选: red | blue | yellow | green | purple&lt;/div&gt;实现方法编辑yoursite/themes/next/source/css/_custom/custom.styl文件，加入如下代码即可：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495span.inline-span &#123; display:inline; padding:.3em .4em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:.2em; margin: auto .5em;&#125;span.yellow &#123; background-color: #f0ad4e;&#125;span.green &#123; background-color: #5cb85c;&#125;span.blue &#123; background-color: #2780e3;&#125;span.purple &#123; background-color: #9954bb;&#125;span.red &#123; background-color: #df3e3e;&#125;div.div-border &#123; display: block; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-radius: 3px;&#125;div.left-red &#123; border-left-width: 5px; border-left-color: #df3e3e;&#125;div.left-yellow &#123; border-left-width: 5px; border-left-color: #f0ad4e;&#125;div.left-green &#123; border-left-width: 5px; border-left-color: #5cb85c;&#125;div.left-blue &#123; border-left-width: 5px; border-left-color: #2780e3;&#125;div.left-purple &#123; border-left-width: 5px; border-left-color: #9954bb;&#125;div.right-red &#123; border-right-width: 5px; border-right-color: #df3e3e;&#125;div.right-yellow &#123; border-right-width: 5px; border-right-color: #f0ad4e;&#125;div.right-green &#123; border-right-width: 5px; border-right-color: #5cb85c;&#125;div.right-blue &#123; border-right-width: 5px; border-right-color: #2780e3;&#125;div.right-purple &#123; border-right-width: 5px; border-right-color: #9954bb;&#125;div.top-red &#123; border-top-width: 5px; border-top-color: #df3e3e;&#125;div.top-yellow &#123; border-top-width: 5px; border-top-color: #f0ad4e;&#125;div.top-green &#123; border-top-width: 5px; border-top-color: #5cb85c;&#125;div.top-blue &#123; border-top-width: 5px; border-top-color: #2780e3;&#125;div.top-purple &#123; border-top-width: 5px; border-top-color: #9954bb;&#125;合并分类和标签到一页命令行先运行1hexo new page categories-tags需要在主题配置文件配置新页面，并且在yoursite/themes/next/layout/page.swig文件中配置相关设置。以上改动部分来自于以下博客，在此表示感谢：Hexo+NexT主题配置备忘 | 量子广告[Hexo] Next主题自定义样式 | lazyBoy.site]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
        <tag>安装教程</tag>
      </tags>
  </entry>
</search>